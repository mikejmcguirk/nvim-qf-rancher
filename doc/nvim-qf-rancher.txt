==============================================================================
Error list husbandry                                       *nvim-qf-rancher.txt*

Nvim Quickfix Rancher provides a stable of tools for taming the quickfix
and location lists:
- Auto opening, closing, and resizing of list windows at logical points
  and across tabpages
- Wrapping and convenience functions for list and stack navigation
- Autocommands to stop automatic copying of location lists to new windows,
  as well as putting location lists without a home window out to pasture
- Preview window for list items
- Built-in functions for lassoing diagnostics of all severities, including
  highest only
- Grep functions built on rg as a default, with grep available
  as a backup
- Filter and sort functions
- Capabilities are extensible and available from the cmd line

==============================================================================
Installation                                           *qf-rancher-installation*

                                                              *qfr-installation*
Neovim 0.11+ is supported

Lazy.nvim:
>
    "mikejmcguirk/nvim-qf-rancher",
    lazy = false,
    init = function()
        -- set g variables here
    end,
<
vim.pack spec (v0.12+):
>
    { src = "https://github.com/mikejmcguirk/nvim-qf-rancher" },
<
Verify installation and settings with ":checkhealth qf-rancher"

==============================================================================
Configuration                                                *qf-rancher-config*

                                                                    *qfr-config*

Qfr is configured using vim.g variables. For lazy.nvim users, make sure to
set these in the "init" section of your plugin spec

The current settings can be verified with "checkhealth qf-rancher"

qfr_auto_center                                                *qfr_auto_center*

    (Default true) Qfr commands will auto-center opened buffers

    Type: ~
        boolean


qfr_auto_open_changes                                    *qfr_auto_open_changes*

    (Default true) Always open the list when its contents are changed

    Type: ~
        boolean


qfr_auto_list_height                                      *qfr_auto_list_height*

    (Default true) When the list is opened, its contents changed, or the
    stack number changed, re-size it to match the amount of entries. Max
    automatic height is 10

    Type: ~
        boolean


qfr_close_on_stack_clear                              *qfr_close_on_stack_clear*

    (Default true) Automatically close the list if the entire stack is cleared

    Type: ~
        boolean


qfr_create_loclist_autocmds                        *qfr_create_loclist_autocmds*

    (Default true) On startup, create autocmds to manage the following:
    - Prevent split windows from inheriting the original window's location
      list
    - When a non-list window is closed, automatically close and clear its
      associated location lists
    These autocmds are contained in the augroup "qfr-loclist-group"

    Type: ~
        boolean


qfr_debug_assertions                                      *qfr_debug_assertions*

    (Default false) Enables extra type checking and logical assertions. This
    can affect performance, as individual list items will have extra
    validation

    Type: ~
        boolean


qfr_always_keep_topline                                *qfr_always_keep_topline*

    (Default true) Temporarily set splitkeep to topline when
    the list is open, closed, or resized. This option is ignored if
    splitkeep is already set for screen or topline

    Type: ~
        boolean


Qf Rancher provides a qf.lua after/ftplugin file to customize list behavior
Customize which |qfr-ftplugin| features to use with the options below

qfr_ftplugin_demap                                          *qfr_ftplugin_demap*

    (Default true) Disable obtrusive defaults

    Type: ~
        boolean


qfr_ftplugin_keymap                                        *qfr_ftplugin_keymap*

    (Default true) Set ack.vim style ftplugin list keymaps

    Type: ~
        boolean


qfr_ftplugin_set_opts                                    *qfr_ftplugin_set_opts*

    (Default true) Set list-specific options

    Type: ~
        boolean


qfr_grepprg                                                        *qfr_grepprg*

    (Default "rg") Set the grepprg used for Rancher's grep functions
    "rg" and "grep" are available

    Type: ~
        string


Control the preview window (|qfr-preview|) with the options below

qfr_preview_border                                          *qfr_preview_border*

    (Default "single") Set the preview window border. See :h 'winborder' for
    more info

    Variants: ~
        ("")
        ("bold")
        ("double")
        ("none")
        ("rounded")
        ("shadow")
        ("single")
        ("solid")
        ("An eight element string[] table")


qfr_preview_debounce                                      *qfr_preview_debounce*

    (Default 100) Minimum interval in ms between preview window updates
    The default is 100 to accommodate slower systems/HDs. On a reasonable
    system, it should be possible to go down to 50ms before flicker/stutter
    start to appear. This behavior also depends on the size of the file(s)
    being scrolled through

    Type: ~
        string


qfr_preview_show_title                                  *qfr_preview_show_title*

    (Default true) Show title in the preview window

    Type: ~
        string


qfr_preview_title_pos                                    *qfr_preview_title_pos*

    (Default "left") If show_title is true, control where it shows

    Type: ~
        string


qfr_preview_winblend                                      *qfr_preview_winblend*

    (Default 0) Set the winblend of the preview win (see :h winblend)

    Type: ~
        integer


qfr_reuse_title                                                *qfr_reuse_title*

    (Default true) When running a Qfr cmd to gather new entries, look for
    destination lists to re-use based on title

    Type: ~
        boolean


qfr_set_default_cmds                                      *qfr_set_default_cmds*

    (Default true) Create Qfr's default commands

    Type: ~
        boolean


qfr_set_default_keymaps                                *qfr_set_default_keymaps*

    (Default true) Set default keymaps (excluding ftplugin maps)
    NOTE: All <Plug> maps are created at startup regardless of this option's
    value. If this option is true, The Window maps (|qfr-window-controls|) and
    and the grep maps (|qfr-grep-maps|) for CWD and help will be created at
    startup. The others will be deferred until BufNew or BufReadPre

    Type: ~
        boolean


==============================================================================
Qfr Window controls                                 *qf-rancher-window-controls*

                                                            *qfr-window-keymaps*
                                                           *qfr-window-commands*


Modes: { n }, Plug: <Plug>(qfr-open-qf-list), Default: "<leader>qp"
 Desc: Open the quickfix list to [count] height (focus if already open)

Modes: { n }, Plug: <Plug>(qfr-close-qf-list), Default: "<leader>qo"
 Desc: Close the quickfix list

Modes: { n }, Plug: <Plug>(qfr-toggle-qf-list), Default: "<leader>qq"
 Desc: Toggle the quickfix list (count sets height on open)

Modes: { n }, Plug: <Plug>(qfr-qf-window), Default: "<leader>qw"
 Desc: Toggle the quickfix list based on recognized errors (count sets height on open)

Modes: { n }, Plug: <Plug>(qfr-open-loclist), Default: "<leader>lp"
 Desc: Open the location list to [count] height (focus if already open)

Modes: { n }, Plug: <Plug>(qfr-close-loclist), Default: "<leader>lo"
 Desc: Close the location list

Modes: { n }, Plug: <Plug>(qfr-toggle-loclist), Default: "<leader>ll"
 Desc: Toggle the location list (count sets height on open)

Modes: { n }, Plug: <Plug>(qfr-ll-window), Default: "<leader>lw"
 Desc: Toggle the location list based on recognized errors (count sets height on open)

Cmd: Qopen
Desc: Open the quickfix list to [count] height (focus if already open)

Cmd: Qclose
Desc: Close the Quickfix list

Cmd: Qtoggle
Desc: Toggle the quickfix list (count sets height on open)

Cmd: Qwindow
Desc: Toggle the quickfix list based on recognized errors (count sets height on open)

Cmd: Lopen
Desc: Open the location list to [count] height (focus if already open)

Cmd: Lclose
Desc: Close the location List

Cmd: Ltoggle
Desc: Toggle the location list (count sets height on open)

Cmd: Lwindow
Desc: Toggle the location list based on recognized errors (count sets height on open)

==============================================================================
Open, close, and resize list wins                                       *Window*

                                                             *qf-rancher-window*
                                                                    *qfr-window*


qf-rancher.window.OpenOpts                          *qf-rancher.window.OpenOpts*

    Fields: ~
        {close_others?}  (boolean)
                         If opening the Quickfix list, close all location
                         lists in the current tab. The reverse if opening the
                         Location list.

        {height?}        (integer) List height to open to

        {on_list?}       (fun(list_win:integer,tabpage:integer))
                         Callback to run if the list is already open

        {on_open?}       (fun(tabpage:integer))
                         Callback to run on list open

        {silent?}        (boolean)
                         Suppress messages (only applies to location lists)

        {split?}         (""|"botright"|"topleft"|"belowright"|"aboveleft")
                         Default "botright". Only applies to opening the
                         quickfix list



Window.open_qf_win({opts?})                                 *Window.open_qf_win*

    Parameters: ~
        {opts?}  (qf-rancher.window.OpenOpts) See |qf-rancher.window.OpenOpts|

                 If height is not provided, the list will be automatically
                 sized if qfr_auto_list_height is true, otherwise set to the
                 max height

    Returns: ~
        (nil)


Window.open_ll_win({opts?})                                 *Window.open_ll_win*

    Parameters: ~
        {opts?}  (qf-rancher.window.OpenOpts) See |qf-rancher.window.OpenOpts|

                 If height is not provided, the list will be automatically
                 sized if qfr_auto_list_height is true, otherwise set to
                 the max height


    Returns: ~
        (nil)


qf-rancher.window.CloseOpts                        *qf-rancher.window.CloseOpts*

    Fields: ~
        {silent?}       (boolean) Suppress messages
        {tabpage?}      (integer) Tabpage to close a list win in
        {use_alt_win?}  (boolean) Go to the alternate window after closing


Window.close_qf_win({opts?})                               *Window.close_qf_win*

    Parameters: ~
        {opts?}  (qf-rancher.window.CloseOpts) See |qf-rancher.window.CloseOpts|

                 If no tabpage opt is provided, the current tabpage will be
                 used

    Returns: ~
        (nil)


Window.close_ll_win({src_win}, {opts?})                    *Window.close_ll_win*

    Parameters: ~
        {src_win}  (integer)
        {opts?}    (qf-rancher.window.CloseOpts)
                   See |qf-rancher.window.CloseOpts|

                   If no tabpage opt is provided, the current tabpage will be
                   used

    Returns: ~
        (nil)


Window.q_toggle({count})                                       *Window.q_toggle*

    Toggle the Quickfix list.

    On open, any open location lists in the current tabpage will be closed

    If the list is closed, and the alternate window can be found, it will be
    focused after closing.


    Parameters: ~
        {count}  (integer|nil) Height on open. nil will autosize

    Returns: ~
        (nil)


Window.l_toggle({count})                                       *Window.l_toggle*

    Toggle the Location list.

    On open, any open Quickfix lists in the current tabpage will be closed

    If the list is closed, and the alternate window can be found, it will be
    focused after closing.


    Parameters: ~
        {count}  (integer|nil) Height on open. nil will autosize

    Returns: ~
        (nil)


Window.q_window({count})                                       *Window.q_window*

    Open/keep open the Quickfix window when there are recognized errors.
    Close/keep closed otherwise.

    On open, any open location lists in the current tabpage will be closed.

    If the list is already open and should stay open, it will be focused.

    If the list is already open and should stay open, it will be resized based
    on count and the value of qfr_auto_list_height.

    If the list should be closed, and the alternate window can be found, it
    will be focused after closing.


    Parameters: ~
        {count}  (integer|nil) Height on open. Nil autosizes

    Returns: ~
        (nil)


Window.l_window({count})                                       *Window.l_window*

    Open/keep open the Loclist window when there are recognized errors.
    Close/keep closed otherwise.

    On open, any open quickfix lists in the current tabpage will be closed.

    If the list is already open and should stay open, it will be focused.

    If the list is already open and should stay open, it will be resized based
    on count and the value of qfr_auto_list_height.

    If the list should be closed, and the alternate window can be found, it
    will be focused after closing.


    Parameters: ~
        {count}  (integer|nil) Height on open. Nil autosizes

    Returns: ~
        (nil)


                                                        *Window.resize_list_win*
Window.resize_list_win({list_win}, {height?})

    Resize a list window. Handles both Quickfix and Location lists.

    If g:qfr_always_keep_topline is true, the list will be resized with |'splitkeep'| set
    to "topline"


    Parameters: ~
        {list_win}  (integer) The list win to resize

                    If nil, the new height will be based on the list contents
        {height?}   (integer)

    Returns: ~
        (nil)


Window.q_open_cmd({cargs})                                   *Window.q_open_cmd*

    Qopen cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.l_open_cmd({cargs})                                   *Window.l_open_cmd*

    Lopen cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.q_close_cmd()                                        *Window.q_close_cmd*

    Qclose cmd callback

    Returns: ~
        (nil)


Window.l_close_cmd()                                        *Window.l_close_cmd*

    Lclose cmd callback

    Returns: ~
        (nil)


Window.q_toggle_cmd({cargs})                               *Window.q_toggle_cmd*

    Qtoggle cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.l_toggle_cmd({cargs})                               *Window.l_toggle_cmd*

    Ltoggle cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.q_window_cmd({cargs})                               *Window.q_window_cmd*

    Qwindow cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.l_window_cmd({cargs})                               *Window.l_window_cmd*

    Lwindow cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Nav controls                                       *qf-rancher-nav-controls*

                                                               *qfr-nav-keymaps*
                                                              *qfr-nav-commands*


Modes: { n }, Plug: <Plug>(qfr-qf-prev), Default: "[q"
 Desc: Go to the [count] previous quickfix entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-next), Default: "]q"
 Desc: Go to the [count] next quickfix entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-rewind), Default: "[Q"
 Desc: Go to the [count] quickfix entry, or the first if no count

Modes: { n }, Plug: <Plug>(qfr-qf-last), Default: "]Q"
 Desc: Go to the [count] quickfix entry, or the last if no count

Modes: { n }, Plug: <Plug>(qfr-qf-pfile), Default: "[<C-q>"
 Desc: Go to the [count] previous quickfix file. Wrap to the last file

Modes: { n }, Plug: <Plug>(qfr-qf-nfile), Default: "]<C-q>"
 Desc: Go to the [count] next quickfix file. Wrap to the first file

Modes: { n }, Plug: <Plug>(qfr-ll-prev), Default: "[l"
 Desc: Go to the [count] previous location list entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-next), Default: "]l"
 Desc: Go to the [count] next location list entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-rewind), Default: "[L"
 Desc: Go to the [count] quickfix entry, or the first if no count

Modes: { n }, Plug: <Plug>(qfr-ll-last), Default: "]L"
 Desc: Go to the [count] quickfix entry, or the last if no count

Modes: { n }, Plug: <Plug>(qfr-ll-pfile), Default: "[<C-l>"
 Desc: Go to the [count] previous quickfix file. Wrap to the last file

Modes: { n }, Plug: <Plug>(qfr-ll-nfile), Default: "]<C-l>"
 Desc: Go to the [count] next quickfix file. Wrap to the first file

Cmd: Qprev
Desc: Go to the [count] previous quickfix entry. Count is wrapping

Cmd: Qnext
Desc: Go to the [count] next quickfix entry. Count is wrapping

Cmd: Qrewind
Desc: Go to the [count] quickfix entry, or the first if no count

Cmd: Qq
Desc: Go to the [count] qf entry, or under the cursor, or current idx

Cmd: Qlast
Desc: Go to the [count] quickfix entry, or the last if no count

Cmd: Qpfile
Desc: Go to the [count] previous quickfix file. Wrap to the last file

Cmd: Qnfile
Desc: Go to the [count] next quickfix file. Wrap to the first file

Cmd: Lprev
Desc: Go to the [count] previous location list entry. Count is wrapping

Cmd: Lnext
Desc: Go to the [count] next location list entry. Count is wrapping

Cmd: Ll
Desc: Go to the [count] loclist entry, or under the cursor, or current idx

Cmd: Lrewind
Desc: Go to the [count] quickfix entry, or the first if no count

Cmd: Llast
Desc: Go to the [count] quickfix entry, or the last if no count

Cmd: Lpfile
Desc: Go to the [count] previous quickfix file. Wrap to the last file

Cmd: Lnfile
Desc: Go to the [count] next quickfix file. Wrap to the first file

==============================================================================
Navigate lists                                                             *Nav*

                                                                *qf-rancher-nav*
                                                                       *qfr-nav*


NOTE: All navigation commands will auto-center the buffer view if
g:qfr_auto_center is true

Nav.q_prev({count}, {opts})                                         *Nav.q_prev*

    Parameters: ~
        {count}  (integer) Wrapping count previous entry to navigate to
        {opts}   (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.q_next({count}, {opts})                                         *Nav.q_next*

    Parameters: ~
        {count}  (integer) Wrapping count next entry to navigate to
        {opts}   (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.l_prev({src_win}, {count}, {opts})                              *Nav.l_prev*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count previous entry to navigate to
        {opts}     (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.l_next({src_win}, {count}, {opts})                              *Nav.l_next*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count next entry to navigate to
        {opts}     (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.q_q({count})                                                       *Nav.q_q*
    If a count is provided, that list entry will be opened
    If no count is provided, and the window focus is on a list, the list item
    under the cursor will be opened (different from default cc/ll behavior)
    If the focus is not in a list, the current list idx will be used

    Parameters: ~
        {count}  (integer) Count entry to navigate to

    Returns: ~
        (nil)


Nav.l_l({src_win}, {count})                                            *Nav.l_l*

    Parameters: ~
        {src_win}  (integer) Count entry to navigate to
        {count}    (integer)

    Returns: ~
        (nil)


Nav.q_rewind({count})                                             *Nav.q_rewind*

    Parameters: ~
        {count}  (integer) Entry to navigate to. First if no count

    Returns: ~
        (nil)


Nav.q_last({count})                                                 *Nav.q_last*

    Parameters: ~
        {count}  (integer) Entry to navigate to. Last if no count

    Returns: ~
        (nil)


Nav.l_rewind({src_win}, {count})                                  *Nav.l_rewind*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Entry to navigate to. First if no count

    Returns: ~
        (nil)


Nav.l_last({src_win}, {count})                                      *Nav.l_last*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Entry to navigate to. Last if no count

    Returns: ~
        (nil)


Nav.q_pfile({count})                                               *Nav.q_pfile*
    NOTE: While the p/nfile commands will wrap to the first or last file
    when trying to navigate past the end, the count cannot be used to wrap to a
    specific entry like with the next/prev commands

    Parameters: ~
        {count}  (integer) Count previous file to navigate to

    Returns: ~
        (nil)


Nav.q_nfile({count})                                               *Nav.q_nfile*

    Parameters: ~
        {count}  (integer)

    Returns: ~
        (nil)


Nav.l_pfile({src_win}, {count})                                    *Nav.l_pfile*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Count previous file to navigate to

    Returns: ~
        (nil)


Nav.l_nfile({src_win}, {count})                                    *Nav.l_nfile*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Count next file to navigate to

    Returns: ~
        (nil)


Nav.q_prev_cmd({cargs})                                         *Nav.q_prev_cmd*
    Qprev cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_next_cmd({cargs})                                         *Nav.q_next_cmd*
    Qnext cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_prev_cmd({cargs})                                         *Nav.l_prev_cmd*
    Lprev cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_next_cmd({cargs})                                         *Nav.l_next_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_q_cmd({cargs})                                               *Nav.q_q_cmd*
    Qq cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_l_cmd({cargs})                                               *Nav.l_l_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_rewind_cmd({cargs})                                     *Nav.q_rewind_cmd*
    Qrewind cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_last_cmd({cargs})                                         *Nav.q_last_cmd*
    Qlast cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_rewind_cmd({cargs})                                     *Nav.l_rewind_cmd*
    Lrewind cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_last_cmd({cargs})                                         *Nav.l_last_cmd*
    Llast cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_pfile_cmd({cargs})                                       *Nav.q_pfile_cmd*
    Qpfile cmd callback. Expects count = 0 in the user_command table
    NOTE: While the p/nfile commands will wrap to the first or last file
    when trying to navigate past the end, the count cannot be used to wrap to a
    specific entry like with the next/prev commands

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_nfile_cmd({cargs})                                       *Nav.q_nfile_cmd*
    Qnfile cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_pfile_cmd({cargs})                                       *Nav.l_pfile_cmd*
    Lpfile cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_nfile_cmd({cargs})                                       *Nav.l_nfile_cmd*
    Lnfile cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Stack controls                                   *qf-rancher-stack-controls*

                                                             *qfr-stack-keymaps*
                                                            *qfr-stack-commands*


Modes: { n }, Plug: <Plug>(qfr-qf-older), Default: "<leader>q["
 Desc: Go to the [count] older quickfix list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-newer), Default: "<leader>q]"
 Desc: Go to the [count] newer quickfix list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-history), Default: "<leader>qQ"
 Desc: Jump to [count] list in the quickfix stack or view the current list

Modes: { n }, Plug: <Plug>(qfr-qf-clear), Default: "<leader>qe"
 Desc: Clear a list from the quickfix stack

Modes: { n }, Plug: <Plug>(qfr-qf-clear-all), Default: "<leader>qE"
 Desc: Clear the quickfix stack

Modes: { n }, Plug: <Plug>(qfr-ll-older), Default: "<leader>l["
 Desc: Go to the [count] older location list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-newer), Default: "<leader>l]"
 Desc: Go to the [count] newer location list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-history), Default: "<leader>lL"
 Desc: Jump to [count] list in the loclist stack or view the current list

Modes: { n }, Plug: <Plug>(qfr-ll-clear), Default: "<leader>le"
 Desc: Clear a list from the loclist stack

Modes: { n }, Plug: <Plug>(qfr-ll-clear-all), Default: "<leader>lE"
 Desc: Clear the loclist stack

Cmd: Qolder
Desc: Go to the [count] older quickfix list. Count is wrapping

Cmd: Qnewer
Desc: Go to the [count] newer quickfix list. Count is wrapping

Cmd: Qhistory
Desc: Jump to [count] list in the quickfix stack or show the entire stack

Cmd: Qdelete
Desc: Delete [count] list "all" lists from the quickfix stack

Cmd: Lolder
Desc: Go to the [count] older location list. Count is wrapping

Cmd: Lnewer
Desc: Go to the [count] newer location list. Count is wrapping

Cmd: Lhistory
Desc: Jump to [count] list in the loclist stack or show the entire stack

Cmd: Ldelete
Desc: Delete [count] list or "all" lists from the loclist stack

==============================================================================
View and edit the list stack                                             *Stack*

                                                              *qf-rancher-stack*
                                                                     *qfr-stack*


qf-rancher.stack.GotoHistoryOpts              *qf-rancher.stack.GotoHistoryOpts*

    Fields: ~
        {silent}  (boolean) Suppress messages


Stack.q_older({count}, {opts?})                                  *Stack.q_older*
    If g:qfr_auto_list_height is true, the list will automatically resize

    Parameters: ~
        {count}  (integer) Wrapping count previous list to go to. Minimum 1
        {opts?}  (qf-rancher.stack.GotoHistoryOpts) See |qfr.stack.GotoHistoryOpts|

    Returns: ~
        (nil)


Stack.q_newer({count}, {opts?})                                  *Stack.q_newer*
    If g:qfr_auto_list_height is true, the list will automatically resize

    Parameters: ~
        {count}  (integer) Wrapping count next list to go to. Minimum 1
        {opts?}  (qf-rancher.stack.GotoHistoryOpts) See |qfr.stack.GotoHistoryOpts|

    Returns: ~
        (nil)


                                                                 *Stack.l_older*
Stack.l_older({src_win}, {count}, {opts?})

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count previous list to go to. Minimum 1
        {opts?}    (qf-rancher.stack.GotoHistoryOpts) See |qfr.stack.GotoHistoryOpts|

    Returns: ~
        (nil)


                                                                 *Stack.l_newer*
Stack.l_newer({src_win}, {count}, {opts?})

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count next list to go to. Minimum 1
        {opts?}    (qf-rancher.stack.GotoHistoryOpts) See |qfr.stack.GotoHistoryOpts|

    Returns: ~
        (nil)


Stack.q_history({count}, {opts?})                              *Stack.q_history*

    Parameters: ~
        {count}  (integer|nil) List number to go to, nil to display the whole
                 stack. A count of 0 shows the current list number (difference
                 from core behavior)
        {opts?}  (qf-rancher.stack.GotoHistoryOpts) See |qfr.stack.GotoHistoryOpts|

    Returns: ~
        (nil)


                                                               *Stack.l_history*
Stack.l_history({src_win}, {count}, {opts?})

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer|nil) List number to go to, nil to display the
                   whole stack. A count of 0 shows the current list number
                   (difference from core behavior)
        {opts?}    (qf-rancher.stack.GotoHistoryOpts) See |qfr.stack.GotoHistoryOpts|

    Returns: ~
        (nil)


Stack.q_clear({count})                                           *Stack.q_clear*
    If the current list is cleared, and g:qfr_auto_list_height is true, the
    list will be resized

    Parameters: ~
        {count}  (integer) List number to clear. 0 for current

    Returns: ~
        (nil)


Stack.l_clear({src_win}, {count})                                *Stack.l_clear*
    If the current list is cleared, and g:qfr_auto_list_height is true, the
    list will be resized

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) List number to clear. 0 for current

    Returns: ~
        (nil)


Stack.q_clear_all()                                          *Stack.q_clear_all*
    Clear the quickfix stack. If g:qfr_close_on_stack_clear is true, close
    all qfwins in all tabs

    Returns: ~
        (nil)


Stack.l_clear_all({src_win})                                 *Stack.l_clear_all*
    Clear a loclist stack. If g:qfr_close_on_stack_clear is true, close
    the location list window
    NOTE: When a location list stack is freed but the window is not closed,
    the qf_id of the location list window is set to zero. When this function
    is run, it searches for all qf_id 0 location list windows in all tabs and
    closes them. If the function is run from within a qf_id 0 location list
    window, it will always run a scan for others to close

    Parameters: ~
        {src_win}  (integer) Location list window context

    Returns: ~
        (nil)


Stack.q_older_cmd({cargs})                                   *Stack.q_older_cmd*
    Qolder cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.q_newer_cmd({cargs})                                   *Stack.q_newer_cmd*
    Qnewer cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_older_cmd({cargs})                                   *Stack.l_older_cmd*
    Lolder cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_newer_cmd({cargs})                                   *Stack.l_newer_cmd*
    Lnewer cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.q_history_cmd({cargs})                               *Stack.q_history_cmd*
    Qhistory cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_history_cmd({cargs})                               *Stack.l_history_cmd*
    Lhistory cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.q_clear_cmd({cargs})                                   *Stack.q_clear_cmd*
    Qclear cmd callback. Expects count = 0 and nargs = "?" in the command
    table

    A count of zero clears the current list

    If "all" (and no other arg) is provided, any count will be overridden and
    the stack will be cleared

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_clear_cmd({cargs})                                   *Stack.l_clear_cmd*
    Lclear cmd callback. Expects count = 0 and nargs = "?" in the command
    table

    A count of zero clears the current list

    If "all" (and no other arg) is provided, any count will be overridden and
    the stack will be cleared

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


IMPLEMENTATION DETAIL:

The history, prev, and next commands all use chistory/lhistory under the
hood. For l_history, l_prev, and l_next, rancher uses nvim_win_call to match
lhistory to the src_win context. The default maps and cmds all use the
current win for src_win

==============================================================================
Qfr Ftplugin controls                             *qf-rancher-ftplugin-controls*

                                                          *qfr-ftplugin-keymaps*


Modes: { n }, Plug: <Plug>(qfr-list-del-one), Default: "dd"
 Desc: Delete the current list line

Modes: { x }, Plug: <Plug>(qfr-list-visual-del), Default: "d"
 Desc: Delete a visual line list selection

Modes: { n }, Plug: <Plug>(qfr-list-toggle-preview), Default: "p"
 Desc: Toggle the list preview win

Modes: { n }, Plug: <Plug>(qfr-list-update-preview-pos), Default: "P"
 Desc: Update the preview win position

Modes: { n }, Plug: <Plug>(qfr-list-prev), Default: "{"
 Desc: Go to the previous list entry, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-next), Default: "}"
 Desc: Go to the next list entry, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-direct-focuswin), Default: "o"
 Desc: Open a list item

Modes: { n }, Plug: <Plug>(qfr-list-open-direct-focuslist), Default: "<C-o>"
 Desc: Open a list item, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-split-focuswin), Default: "s"
 Desc: Open a list item in a split

Modes: { n }, Plug: <Plug>(qfr-list-open-split-focuslist), Default: "<C-s>"
 Desc: Open a list item in a split, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-vsplit-focuswin), Default: "v"
 Desc: Open a list item in a vsplit

Modes: { n }, Plug: <Plug>(qfr-list-open-vsplit-focuslist), Default: "<C-v>"
 Desc: Open a list item in a vsplit, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-tabnew-focuswin), Default: "x"
 Desc: Open a list item in a new tab

Modes: { n }, Plug: <Plug>(qfr-list-open-tabnew-focuslist), Default: "<C-x>"
 Desc: Open a list item in a new tab, keep list focus

==============================================================================
List buffer specific features                                         *Ftplugin*

                                                           *qf-rancher-ftplugin*
                                                                  *qfr-ftplugin*


If g:qfr_ftplugin_set_opts is true, the following will be set:

- buflisted = false
- colorcolumn = ""
- list = false
- spell = false

If g:qfr_ftplugin_demap is true, disable the following defaults:

- <C-w>s (split)
- <C-w>v (vsplit)

The |qf-rancher-ftplugin-keymaps| will be set if g:qfr_ftplugin_keymap
is true.

Additionally, the "older" and "newer" functions will be mapped to "<" and ">"
Like the standard keymaps, they take a wrapping count

NOTE: The [count] for the ftplugin specific maps specifies which window
number to open the entry to. If no count is provided, Qfr will emulate
Neovim's default behavior. For Quickfix windows, this includes respecting
"useopen", "usetab", and "uselast" switchbuf behavior (Location list
windows use "useopen" only). Help entries will attempt to find a help
window If a valid window cannot be found, a new split will always be
created above the list

==============================================================================
Qfr Grep controls                                     *qf-rancher-grep-controls*

                                                              *qfr-grep-keymaps*
                                                             *qfr-grep-commands*


Modes: { n, x }, Plug: <Plug>(qfr-qgrep-cwd), Default: "<leader>qgd"
 Desc: Quickfix grep CWD (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-cwdX), Default: "<leader>qgD"
 Desc: Quickfix grep CWD (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cwd), Default: "<leader>lgd"
 Desc: Loclist grep CWD (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cwdX), Default: "<leader>lgD"
 Desc: Loclist grep CWD (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-help), Default: "<leader>lgh"
 Desc: Loclist grep help (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-helpX), Default: "<leader>lgH"
 Desc: Loclist grep help (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-bufs), Default: "<leader>qgu"
 Desc: Quickfix grep open bufs (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-bufsX), Default: "<leader>qgU"
 Desc: Quickfix grep bufs (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cbuf), Default: "<leader>lgu"
 Desc: Loclist grep cur buf (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cbufX), Default: "<leader>lgU"
 Desc: Loclist grep cur buf (regex)

Cmd: Qgrep
Desc: Grep to the quickfix list

Cmd: Lgrep
Desc: Grep to the location list

==============================================================================
Grep items into the list                                                  *Grep*

                                                               *qf-rancher-grep*
                                                                      *qfr-grep*


QfrGrepLocsFunc                                                *QfrGrepLocsFunc*

    Type: ~
        fun():string[]


QfrGrepOpts                                                        *QfrGrepOpts*

    Fields: ~
        {case?}       (QfrCase) "insensitive"|"sensitive"|"smartcase"|"vimcase"
        {locations?}  (string[]|QfrGrepLocsFunc) A string list or a function
                      returning a string list to provide locations to grep to.
                      Pre-built location functions are available in
                      "qf-rancher.lib.grep_locs"
        {name?}       (string) Display name of the grep for prompting
        {pattern}     (string|nil) Pattern to grep. If nil, either a prompt
                      will display in normal mode or the selection will be
                      used in visual mode
        {regex?}      (boolean) If false, use fixed strings when grepping


                                                                     *Grep.grep*
Grep.grep({src_win}, {action}, {what}, {grep_opts}, {system_opts})
    Run a grep

    The list title will be set to:
    "[grep name] [base grep cmd] [pattern]"

    Use "checkhealth qf-rancher" to verify the status of the current
    g:qfr_grepprg value
    Note that this module will run an external grep, and thus must target
    valid files and directories

    If g:qfr_reuse_title is true, output_opts.action is " ", and a list
    with the grep's title already exists, that list will be reused

    If run in Visual mode, the selection will be used as the grep pattern.
    Nvim will return to Normal mode.

    This command uses the |qfr-system| module to run the grep and print
    results

    Parameters: ~
        {src_win}      (integer|nil) Location list window context. Nil for qflist
        {action}       (qf-rancher.types.Action) See |setqflist-action|
        {what}         (qf-rancher.What) See |setqflist-what|
        {grep_opts}    (QfrGrepOpts) See |QfrGrepOpts|
        {system_opts}  (qf-rancher.SystemOpts) See |QfrSystemOpts|

    Returns: ~
        (nil)


QfrGrepInfo                                                        *QfrGrepInfo*

    Fields: ~
        {grep_opts}  (QfrGrepOpts) See |QfrGrepOpts|
        {sys_opts}   (qf-rancher.SystemOpts) See |QfrSystemOpts|


The callbacks to assign the Qgrep and Lgrep commands are below. They expect
count = 0 and nargs = "*" to be present in the user_command table.
They accept the following options:
- A registered grep name (cwd|help|bufs|cbuf). cwd is default
  NOTE: "bufs" searches all open bufs, excluding help bufs
  NOTE: "cbuf" searches the current buf, including help buffers
  NOTE: The built in quickfix buf grep keymap searches all open bufs.
  The location list grep searches the current buf
- A pattern starting with "/"
- A |qfr-input-type| ("vimcase" by default)
- "async" or "sync" to control system behavior (async by default)
- A |setqflist-action| (default " ")
Example: 2Qgrep help r vimcase /setqflist

Grep.q_grep_cmd({cargs})                                       *Grep.q_grep_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Grep.l_grep_cmd({cargs})                                       *Grep.l_grep_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Diagnostic controls                         *qf-rancher-diagnostic-controls*

                                                        *qfr-diagnostic-keymaps*
                                                       *qfr-diagnostic-commands*


Modes: { n }, Plug: <Plug>(qfr-Qdiags-hint), Default: "<leader>qin"
 Desc: All diagnostics to quickfix

Modes: { n }, Plug: <Plug>(qfr-Qdiags-info), Default: "<leader>qif"
 Desc: Diagnostics to quickfix, min info

Modes: { n }, Plug: <Plug>(qfr-Qdiags-warn), Default: "<leader>qiw"
 Desc: Diagnostics to quickfix, min warn

Modes: { n }, Plug: <Plug>(qfr-Qdiags-error), Default: "<leader>qie"
 Desc: Diagnostics to quickfix, min error

Modes: { n }, Plug: <Plug>(qfr-Qdiags-top), Default: "<leader>qit"
 Desc: Diagnostics to quickfix, top severity

Modes: { n }, Plug: <Plug>(qfr-Qdiags-hint-only), Default: "<leader>qiN"
 Desc: Diagnostics to quickfix, only hints

Modes: { n }, Plug: <Plug>(qfr-Qdiags-info-only), Default: "<leader>qiF"
 Desc: Diagnostics to quickfix, only info

Modes: { n }, Plug: <Plug>(qfr-Qdiags-warn-only), Default: "<leader>qiW"
 Desc: Diagnostics to quickfix, only warnings

Modes: { n }, Plug: <Plug>(qfr-Qdiags-error-only), Default: "<leader>qiE"
 Desc: Diagnostics to quickfix, only errors

Modes: { n }, Plug: <Plug>(qfr-Ldiags-hint), Default: "<leader>lin"
 Desc: All cur buf diagnostics to loclist

Modes: { n }, Plug: <Plug>(qfr-Ldiags-info), Default: "<leader>lif"
 Desc: Cur buf diagnostics to loclist, min info

Modes: { n }, Plug: <Plug>(qfr-Ldiags-warn), Default: "<leader>liw"
 Desc: Cur buf diagnostics to loclist, min warn

Modes: { n }, Plug: <Plug>(qfr-Ldiags-error), Default: "<leader>lie"
 Desc: Cur buf diagnostics to loclist, min error

Modes: { n }, Plug: <Plug>(qfr-Ldiags-top), Default: "<leader>lit"
 Desc: Cur buf diagnostics to loclist, top severity

Modes: { n }, Plug: <Plug>(qfr-Ldiags-hint-only), Default: "<leader>liN"
 Desc: Cur buf diagnostics to loclist, only hints

Modes: { n }, Plug: <Plug>(qfr-Ldiags-info-only), Default: "<leader>liF"
 Desc: Cur buf diagnostics to loclist, only info

Modes: { n }, Plug: <Plug>(qfr-Ldiags-warn-only), Default: "<leader>liW"
 Desc: Cur buf diagnostics to loclist, only warnings

Modes: { n }, Plug: <Plug>(qfr-Ldiags-error-only), Default: "<leader>liE"
 Desc: Cur buf diagnostics to loclist, only errors

Cmd: Qdiag
Desc: Send diags to the Quickfix list

Cmd: Ldiag
Desc: Send buf diags to the Location list

==============================================================================
Sends diags to the qf list                                                *Diag*

                                                        *qf-rancher-diagnostics*
                                                               *qfr-diagnostics*


qf-rancher.diag.DiagOpts                              *qf-rancher.diag.DiagOpts*

    Fields: ~
        {disp_func?}  (qf-rancher.diag.DisplayFunc)
                      List entry conversion function
        {top?}        (boolean) If true, only show top severity
        {getopts?}    (vim.diagnostic.GetOpts) See |vim.diagnostic.Getopts|


                                                            *Diag.diags_to_list*
Diag.diags_to_list({diag_opts}, {output_opts})

    Convert diagnostics into list entries

    In line with Neovim's default, the list title will be "Diagnostics"

    If g:qfr_reuse_title is true, output_opts.action is " ", and a list with
    the title "Diagnostics" already exists, it will be re-used

    If a query is made for all diagnostics in a scope, and no results return,
    the "Diagnostics" list will be automatically cleared


    Parameters: ~
        {diag_opts}    (qf-rancher.diag.DiagOpts)
        {output_opts}  (QfrOutputOpts) See |qfr-output-opts|

    Returns: ~
        (nil)


The callbacks to assign the Qdiag and Ldiag commands are below. They expect
count = 0, nargs = "*", and bang = true to be in the user_command table.

Qdiag checks all open buffers. Ldiag checks the current buffer

They accept the following options:
- A diagnostic severity ("error"|"warn"|"hint"|"info") or "top"
- A |setqflist-action| (default " ")

If a bang is provided, only the specified severity will be shown

Examples:
Qdiag error [show all errors]
Ldiag! warn only [show only warnings from the current buffer]

Diag.q_diag_cmd({cargs})                                       *Diag.q_diag_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Diag.l_diag_cmd({cargs})                                       *Diag.l_diag_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Filter controls                                 *qf-rancher-filter-controls*

                                                            *qfr-filter-keymaps*
                                                           *qfr-filter-commands*


Modes: { n, x }, Plug: <Plug>(qfr-qfilter-cfilter), Default: "<leader>qkl"
 Desc: Qfilter keep cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-cfilter), Default: "<leader>qrl"
 Desc: Qfilter remove cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-cfilterX), Default: "<leader>qkL"
 Desc: Qfilter keep cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-cfilterX), Default: "<leader>qrL"
 Desc: Qfilter remove cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-cfilter), Default: "<leader>lkl"
 Desc: Lfilter keep cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-cfilter), Default: "<leader>lrl"
 Desc: Lfilter remove cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-cfilterX), Default: "<leader>lkL"
 Desc: Lfilter keep cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-cfilterX), Default: "<leader>lrL"
 Desc: Lfilter remove cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-fname), Default: "<leader>qkf"
 Desc: Qfilter keep fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-fname), Default: "<leader>qrf"
 Desc: Qfilter remove fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-fnameX), Default: "<leader>qkF"
 Desc: Qfilter keep fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-fnameX), Default: "<leader>qrF"
 Desc: Qfilter remove fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-fname), Default: "<leader>lkf"
 Desc: Lfilter keep fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-fname), Default: "<leader>lrf"
 Desc: Lfilter remove fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-fnameX), Default: "<leader>lkF"
 Desc: Lfilter keep fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-fnameX), Default: "<leader>lrF"
 Desc: Lfilter remove fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-text), Default: "<leader>qke"
 Desc: Qfilter keep text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-text), Default: "<leader>qre"
 Desc: Qfilter remove text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-textX), Default: "<leader>qkE"
 Desc: Qfilter keep text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-textX), Default: "<leader>qrE"
 Desc: Qfilter remove text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-text), Default: "<leader>lke"
 Desc: Lfilter keep text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-text), Default: "<leader>lre"
 Desc: Lfilter remove text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-textX), Default: "<leader>lkE"
 Desc: Lfilter keep text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-textX), Default: "<leader>lrE"
 Desc: Lfilter remove text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-lnum), Default: "<leader>qkn"
 Desc: Qfilter keep lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-lnum), Default: "<leader>qrn"
 Desc: Qfilter remove lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-lnumX), Default: "<leader>qkN"
 Desc: Qfilter keep lnum (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-lnumX), Default: "<leader>qrN"
 Desc: Qfilter remove lnum (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-lnum), Default: "<leader>lkn"
 Desc: Lfilter keep lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-lnum), Default: "<leader>lrn"
 Desc: Lfilter remove lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-lnumX), Default: "<leader>lkN"
 Desc: Lfilter keep lnum (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-lnumX), Default: "<leader>lrN"
 Desc: Lfilter remove lnum (regex)

Cmd: Qfilter
Desc: Filter quickfix items

Cmd: Lfilter
Desc: Filter location list items

==============================================================================
Filter list items                                                       *Filter*

                                                             *qf-rancher-filter*
                                                                    *qfr-filter*


                                                     *qf-rancher-predicate-opts*
                                                            *qfr-predicate-opts*
QfrPredicateOpts                                              *QfrPredicateOpts*
    NOTE: Each predicate function will use only pattern or regex

    Fields: ~
        {pattern?}  (string) Pattern to filter against
        {regex?}    (vim.regex) Regex to filter against


                                                   *qf-rancher-filter-predicate*
                                                          *qfr-filter-predicate*
QfrFilterPredicate                                          *QfrFilterPredicate*
    Fields:
    - vim.qflist.entry
    - boolean (true for keep, false for remove)
    - QfrPredicateOpts |qfr-predicate-opts|
    Returns: boolean

    Type: ~
        fun


                                                        *qf-rancher-filter-info*
                                                               *qfr-filter-info*
QfrFilterInfo                                                    *QfrFilterInfo*
    NOTE: The filter logic will resolve vimcase and smartcase to either
    case-sensitive or insensitive

    Fields: ~
        {name}              (string) Name if the filter, used for cmds
        {insensitive_func}  (QfrFilterPredicate) Case-insensitive predicate
        {regex_func}        (QfrFilterPredicate) Regex predicate
        {sensitive_func}    (QfrFilterPredicate) Case-sensitive predicate


                                                                 *Filter.filter*
Filter.filter({name}, {keep}, {input_opts}, {output_opts})

    Parameters: ~
        {name}         (string)
        {keep}         (boolean) If true, matched patterns will be
                       kept in the list. If false, removed
        {input_opts}   (QfrInputOpts) See |qfr-input-opts|
                       If a pattern is provided, that will be used for the
                       filter. If not, the user will be prompted for one in
                       normal mode, or the current visual selection will be
                       used
        {output_opts}  (QfrOutputOpts) See |qfr-output-opts|
                       If vim.v.count is > 0, that will be used to
                       determine the list nr to be acted on

    Returns: ~
        (nil)


Filter.register_filter({filter_info})                   *Filter.register_filter*
    Register a fitler for use in commands and API Calls

    Parameters: ~
        {filter_info}  (QfrFilterInfo) The filter will be
                       registered under the name provided in this table

    Returns: ~
        (nil)


Filter.clear_filter({name})                                *Filter.clear_filter*
    Remove a registered filter. The last filer cannot be removed

    Parameters: ~
        {name}  (string)

    Returns: ~
        (nil)


The callbacks to assign the Qfilter and Lfilter commands are below. They
expect count = 0 and nargs = "*" to be present in the user_command table.
They accept the following options:
- A registered filter name. (cfilter|fname|lnum|text|type) cfilter is default
  NOTE: The "cfilter" option is an emulation of the built-in Cfilter plugin
  NOTE: For the "lnum" filter, the case-insensitive filter will function like
     a "contains" filter, whereas the case-sensitive filter requires an exact
     match
- A pattern starting with "/"
- A |qfr-input-type| ("vimcase" by default)
- A |setqflist-action| (default "u")
- If a bang is provided, the filter will remove instead of keeping matched
  items
- If a count is provided, that list number will be used. The default is the
  current list
Example: 3Qfilter! cfilter r vimcase /require

Filter.q_filter_cmd({cargs})                               *Filter.q_filter_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Filter.l_filter_cmd({cargs})                               *Filter.l_filter_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Sort controls                                     *qf-rancher-sort-controls*

                                                              *qfr-sort-keymaps*
                                                             *qfr-sort-commands*


Modes: { n }, Plug: <Plug>(qfr-qsort-fname-asc), Default: "<leader>qtf"
 Desc: Sort quickfix by fname asc

Modes: { n }, Plug: <Plug>(qfr-qsort-fname-desc), Default: "<leader>qtF"
 Desc: Sort quickfix by fname desc

Modes: { n }, Plug: <Plug>(qfr-qsort-fname-diag-asc), Default: "<leader>qtif"
 Desc: Sort quickfix by fname_diag asc

Modes: { n }, Plug: <Plug>(qfr-qsort-fname-diag-desc), Default: "<leader>qtiF"
 Desc: Sort quickfix by fname_diag desc

Modes: { n }, Plug: <Plug>(qfr-qsort-severity-asc), Default: "<leader>qtis"
 Desc: Sort quickfix by severity asc

Modes: { n }, Plug: <Plug>(qfr-qsort-severity-desc), Default: "<leader>qtiS"
 Desc: Sort quickfix by severity desc

Modes: { n }, Plug: <Plug>(qfr-qsort-text-asc), Default: "<leader>qte"
 Desc: Sort quickfix by text asc

Modes: { n }, Plug: <Plug>(qfr-qsort-text-desc), Default: "<leader>qtE"
 Desc: Sort quickfix by text desc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-asc), Default: "<leader>ltf"
 Desc: Sort location list by fname asc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-desc), Default: "<leader>ltF"
 Desc: Sort location list by fname desc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-diag-asc), Default: "<leader>ltif"
 Desc: Sort location list by fname_diag asc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-diag-desc), Default: "<leader>ltiF"
 Desc: Sort location list by fname_diag desc

Modes: { n }, Plug: <Plug>(qfr-lsort-severity-asc), Default: "<leader>ltis"
 Desc: Sort location list by severity asc

Modes: { n }, Plug: <Plug>(qfr-lsort-severity-desc), Default: "<leader>ltiS"
 Desc: Sort location list by severity desc

Modes: { n }, Plug: <Plug>(qfr-lsort-text-asc), Default: "<leader>lte"
 Desc: Sort location list by text asc

Modes: { n }, Plug: <Plug>(qfr-lsort-text-desc), Default: "<leader>ltE"
 Desc: Sort location list by text desc

Cmd: Qsort
Desc: Sort quickfix items

Cmd: Lsort
Desc: Sort location list items

==============================================================================
Sort list items                                                           *Sort*

                                                               *qf-rancher-sort*
                                                                      *qfr-sort*


                                                     *qf-rancher-sort-predicate*
                                                            *qfr-sort-predicate*
qf-rancher.sort.Predicate                            *qf-rancher.sort.Predicate*
    Parameters:
    - vim.qflist.item (first item to sort)
    - vim.qflist.item (second item to sort)
    Return: Boolean

    Type: ~
        fun


                                                                     *Sort.sort*
Sort.sort({pred}, {src_win}, {action}, {nr})

    Parameters: ~
        {pred}     (qf-rancher.sort.Predicate) A function to sort the list items
        {src_win}  (integer|nil) Optional location list window context
        {action}   (qf-rancher.types.Action) What action to take when setting the list
        {nr}       (integer|"$") Which list nr to operate on

    Returns: ~
        (nil)


                                                          *qf-rancher-sort-info*
                                                                 *qfr-sort-info*
qf-rancher.sort.Info                                      *qf-rancher.sort.Info*

    Fields: ~
        {asc}   (qf-rancher.sort.Predicate) Predicate for asc Sort.sorts
        {desc}  (qf-rancher.sort.Predicate) Predicate for desc Sort.sorts


Sort.sorts                                                          *Sort.sorts*
    Sorts available to the Qsort and Lsort cmds. The string table key can be
    fed to those cmds as an argument to use the sorts. Because this table is
    public, sorts can be directly added or removed
    Pre-built sorts are available in "qf-rancher.lib.sort"

    Type: ~
        (table<string,qf-rancher.sort.Info>)


QfrSortDir                                                          *QfrSortDir*

    Type: ~
        "asc"|"desc"


The callbacks to assign the Qsort and Lsort commands are below. They
expect count = 0 and nargs = 1 to be present in the user_command table.
They accept the following options:
- A registered sort name (fname|fname_diag|severity|text|type)
  fname is the default
  NOTE: fname_diag Sort.sorts by filename, with subsorting by diagnostic
  severity
- A |setqflist-action| can also be provided (default "u")
- If a bang is provided, the sort will be in descending order
- If a count is provided, that list nr will be used. Default is the current
  list
Example: 4Qsort! fname r

Sort.q_sort({cargs})                                               *Sort.q_sort*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Sort.l_sort({cargs})                                               *Sort.l_sort*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Send system cmd results to the list                                     *System*

                                                             *qf-rancher-system*
                                                                    *qfr-system*


                                                              *System.system_do*
System.system_do({cmd_parts}, {src_win}, {action}, {what}, {system_opts})
    Run a system command and send the results to a list

    Parameters: ~
        {cmd_parts}    (string[]) Command to execute
        {src_win}      (integer|nil) Location list window nr, or nil to set to
                       the quickfix list
        {action}       (qf-rancher.types.Action) See |setqflist-action|
        {what}         (qf-rancher.What) See |setqflist-what|
        {system_opts}  (qf-rancher.SystemOpts) See |qfr-system-opts|

    Returns: ~
        (nil)


==============================================================================
Preview List Items                                                     *Preview*

                                                            *qf-rancher-preview*
                                                                   *qfr-preview*


Preview.update_preview_win_buf()                *Preview.update_preview_win_buf*
    Update the preview window buffer based on the current list cursor position

    Returns: ~
        (nil)


Preview.update_preview_win_pos()                *Preview.update_preview_win_pos*
    Re-snap the preview window to the list

    Returns: ~
        (nil)


Preview.open_preview_win({list_win})                  *Preview.open_preview_win*
    Open the preview window. Sets up buffer cache data
    If the preview window is already open, this function is
    a nop

    Parameters: ~
        {list_win}  (integer) List window context

    Returns: ~
        (nil)


Preview.close_preview_win()                          *Preview.close_preview_win*
    Close the preview window

    Returns: ~
        (nil)


Preview.toggle_preview_win({list_win})              *Preview.toggle_preview_win*
    Toggle the preview window
    If the preview window is open in a different list than the one this
    function is run in, the open preview window will be closed first

    Parameters: ~
        {list_win}  (integer) List window context

    Returns: ~
        (nil)


==============================================================================
API Types                                                                *Types*

                                                              *qf-rancher-types*
                                                                     *qfr-types*
                                                          *qf-rancher-api-types*
                                                                 *qfr-api-types*


                                                         *qf-rancher-input-type*
                                                                *qfr-input-type*
QfrInputType                                                      *QfrInputType*
    - "insensitive" will always treat the input as case insensitive
    - "regex" will use a regex search. The type of regex is cmd dependent
    - "sensitive" provides a case sensitive search
    - "smartcase" will be case insensitive only if the serach is all lowercase
    - "vimcase" respect the 'ignorecase' and 'smartcase' options

    Variants: ~
        ("insensitive")
        ("regex")
        ("sensitive")
        ("smartcase")
        ("vimcase")


                                                         *qf-rancher-input-opts*
                                                                *qfr-input-opts*
QfrInputOpts                                                      *QfrInputOpts*

    Fields: ~
        {input_type}  (QfrInputType)
        {prompt?}     (string) User prompt for entering pattern
        {pattern?}    (string) The search pattern for the function


                                                        *qf-rancher-system-opts*
                                                               *qfr-system-opts*
qf-rancher.SystemOpts                                    *qf-rancher.SystemOpts*

    Fields: ~
        {list_item_type?}  (string) Usually blank. "\1" for help buffers
        {sort_func?}       (function) A function from the sort module
        {sync?}            (boolean) Run the operation syncrhonously
        {timeout?}         (integer) How long to wait.
                           Default 2000 (sync and async)


                                                        *qf-rancher-output-opts*
                                                               *qfr-output-opts*
QfrOutputOpts                                                    *QfrOutputOpts*

    Fields: ~
        {list_item_type?}  (string) Usually blank. "\1" for help buffers
        {sort_func?}       (function) A function from the sort module
        {src_win}          (integer|nil) Loclist win context. Quickfix if nil
        {action}           (qf-rancher.types.Action) See |setqflist-action|
        {what}             (qf-rancher.What) See |setqflist-what|


vim:tw=78:ts=8:noet:ft=help:norl:
