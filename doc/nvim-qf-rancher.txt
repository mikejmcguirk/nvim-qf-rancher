==============================================================================
Error list husbandry                                       *nvim-qf-rancher.txt*

Nvim Quickfix Rancher provides a stable of tools for taming the quickfix
and location lists:
- Auto opening, closing, and resizing of list windows at logical points
  and across tabpages
- Wrapping and convenience functions for list and stack navigation
- Autocommands to stop automatic copying of location lists to new windows,
  as well as putting location lists without a home window out to pasture
- Preview window for list items
- Built-in functions for lassoing diagnostics by all severities, including
  highest only
- Filter and sort functions
- A variey of grep functions built on rg as a default, with grep available
  as a backup
- Capabilities are extensible and available from the cmd line

==============================================================================
Installation                                           *qf-rancher-installation*

                                                              *qfr-installation*
==============================================================================
Configuration                                                *qf-rancher-config*

                                                                    *qfr-config*

Qfr is configured using vim.g variables. For lazy.nvim users, make sure to
set thse in the "init" section of your plugin spec

qfr_auto_center_result                                  *qfr_auto_center_result*

    (Default true) Qfr commands will auto-center opened buffers

    Type: ~
        string


qfr_auto_open_changes                                    *qfr_auto_open_changes*

    (Default true) Always open the list when its contents are changed

    Type: ~
        boolean


qfr_auto_list_height                                      *qfr_auto_list_height*

    (Default true) When the list is opened, its contents changed, or the
    stack number changed, re-size it to match the amount of entries. Max
    automatic height is 10

    Type: ~
        boolean


qfr_close_on_stack_clear                              *qfr_close_on_stack_clear*

    (Default true) Automatically close the list if the entire stack is cleared

    Type: ~
        boolean


qfr_create_loclist_autocmds                        *qfr_create_loclist_autocmds*

    (Default true) On startup, create autocmds to manage the following:
    - Prevent split windows from inheriting the original window's location
      list
    - When a non-list window is closed, automatically close and clear its
      associated location lists
    These autocmds are contained in the augroup "qfr-loclist-group"

    Type: ~
        boolean


qfr_debug_assertions                                      *qfr_debug_assertions*

    (Default false) Enables extra type checking and logical assertions. This
    can affect performance, as individual list items will have extra
    validation

    Type: ~
        boolean


qfr_save_views                                                  *qfr_save_views*

    (Default true) Save views of other windows in the same tab when
    the list is open, closed, or resized. This option is ignored if
    splitkeep is set for screen or topline

    Type: ~
        boolean


Qf Rancher provides a qf.lua after/ftplugin file to customize list behavior
Customize which |qfr-ftplugin| features to use with the options below

qfr_ftplugin_demap                                          *qfr_ftplugin_demap*

    (Default true) Disable obtrusive defaults

    Type: ~
        boolean


qfr_ftplugin_keymap                                        *qfr_ftplugin_keymap*

    (Default true) Set ack.vim style ftplugin list keymaps

    Type: ~
        boolean


qfr_ftplugin_set_opts                                    *qfr_ftplugin_set_opts*

    (Default true) Set list-specific options

    Type: ~
        boolean


qfr_grepprg                                                        *qfr_grepprg*

    (Default "rg") Set the grepprg used for Rancher's grep functions
    "rg" and "grep" are available

    Type: ~
        string


Control the preview window with the options below
TODO: link to preview win section

qfr_preview_border                                          *qfr_preview_border*

    (Default "single") Set the preview window border. See :h 'winborder' for
    more info

    Variants: ~
        ("")
        ("bold")
        ("double")
        ("none")
        ("rounded")
        ("shadow")
        ("single")
        ("solid")
        ("An eight element string[] table")


qfr_preview_debounce                                      *qfr_preview_debounce*

    (Default 100) Minimum interval in ms between preview window updates
    The default is 100 to accommodate slower systems/HDs. On a reasonable
    system, it should be possible to go down to 50ms before flicker/stutter
    start to appear. This behavior also depends on the size of the file(s)
    being scrolled through

    Type: ~
        string


qfr_preview_show_title                                  *qfr_preview_show_title*

    (Default true) Show title in the preview window

    Type: ~
        string


qfr_preview_title_pos                                    *qfr_preview_title_pos*

    (Default "left") If show_title is true, control where it shows

    Type: ~
        string


qfr_preview_winblend                                      *qfr_preview_winblend*

    (Default 0) Set the winblend of the preview win (see :h winblend)

    Type: ~
        integer


qfr_qfsplit                                                        *qfr_qfsplit*

    (Default "botright") Set the split the quickfix list opens to

    Variants: ~
        ("aboveleft")
        ("belowright")
        ("topleft")
        ("botright")


qfr_reuse_title                                                *qfr_reuse_title*

    (Default true) When running a Qfr cmd to gather new entries, look for
    destination lists to re-use based on title

    Type: ~
        boolean


qfr_set_default_cmds                                      *qfr_set_default_cmds*

    (Default true) Create Qfr's default commands

    Type: ~
        boolean


qfr_set_default_keymaps                                *qfr_set_default_keymaps*

    (Default true) Set default keymaps (excluding ftplugin maps)
    NOTE: All <Plug> maps are created at startup regardless of this option's
    value. If this option is true, The Window maps (|qfr-window-controls|) and
    and the grep maps (|qfr-grep-maps|) for CWD and help will be created at
    startup. The others will be deferred until BufNew or BufReadPre

    Type: ~
        boolean


                                                          *qf-rancher-api-types*
                                                                 *qfr-api-types*


                                                         *qf-rancher-input-type*
                                                                *qfr-input-type*
QfrInputType                                                      *QfrInputType*
    - "insensitive" will always treat the input as case insensitive
    - "regex" will use a regex search. The type of regex is cmd dependent
    - "sensitive" provides a case sensitive search
    - "smartcase" will be case insensitive only if the serach is all lowercase
    - "vimcase" respect the 'ignorecase' and 'smartcase' options

    Variants: ~
        ("insensitive")
        ("regex")
        ("sensitive")
        ("smartcase")
        ("vimcase")


                                                         *qf-rancher-input-opts*
                                                                *qfr-input-opts*
QfrInputOpts                                                      *QfrInputOpts*

    Fields: ~
        {input_type}  (QfrInputType)
        {pattern?}    (string) The search pattern for the function


                                                        *qf-rancher-system-opts*
                                                               *qfr-system-opts*
QfrSystemOpts                                                    *QfrSystemOpts*

    Fields: ~
        {sync?}       (boolean) Run the operation syncrhonously
        {cmd_parts?}  (string[]) String parts to build the command from
        {timeout?}    (integer) How long to wait. Default 2000 (sync and async)


                                                        *qf-rancher-output-opts*
                                                               *qfr-output-opts*
QfrOutputOpts                                                    *QfrOutputOpts*

    Fields: ~
        {list_item_type?}  (string) Usually blank. "\1" for help buffers
        {sort_func?}       (function) A function from the sort module
        {src_win}          (integer|nil) Loclist win context. Quickfix if nil
        {action}           (QfrAction) See |setqflist-action|
        {what}             (QfrWhat) See |setqflist-what|


==============================================================================
Qfr Window controls                                 *qf-rancher-window-controls*

                                                            *qfr-window-keymaps*
                                                           *qfr-window-commands*


Modes: { n }, Plug: <Plug>(qfr-open-qf-list), Default: "<leader>qp"
 Desc: Open the quickfix list to [count] height (focus if already open)

Modes: { n }, Plug: <Plug>(qfr-open-qf-list-max), Default: "<leader>qP"
 Desc: Open the quickfix list to max height

Modes: { n }, Plug: <Plug>(qfr-close-qf-list), Default: "<leader>qo"
 Desc: Close the quickfix list

Modes: { n }, Plug: <Plug>(qfr-toggle-qf-list), Default: "<leader>qq"
 Desc: Toggle the quickfix list (count sets height on open)

Modes: { n }, Plug: <Plug>(qfr-open-loclist), Default: "<leader>lp"
 Desc: Open the location list to [count] height (focus if already open)

Modes: { n }, Plug: <Plug>(qfr-open-loclist-max), Default: "<leader>lP"
 Desc: Open the location list to max height

Modes: { n }, Plug: <Plug>(qfr-close-loclist), Default: "<leader>lo"
 Desc: Close the location list

Modes: { n }, Plug: <Plug>(qfr-toggle-loclist), Default: "<leader>ll"
 Desc: Toggle the location list (count sets height on open)

Cmd: Qopen
Desc: Open the quickfix list to [count] height (focus if already open)

Cmd: Qclose
Desc: Close the Quickfix list

Cmd: Qtoggle
Desc: Toggle the quickfix list (count sets height on open)

Cmd: Lopen
Desc: Open the location list to [count] height (focus if already open)

Cmd: Lclose
Desc: Close the location List

Cmd: Ltoggle
Desc: Toggle the location list (count sets height on open)

==============================================================================
Open, close, and resize list wins                                       *Window*

                                                             *qf-rancher-window*
                                                                    *qfr-window*


QfrListOpenOpts                                                *QfrListOpenOpts*

    Fields: ~
        {height?}       (integer) Height the list should be set to
        {keep_win?}     (boolean) Stay in current window when opening the list?
        {nop_if_open?}  (boolean) Do not print messages or focus on the list win


Window.open_qflist({opts})                                  *Window.open_qflist*
    - If any location lists are open in the same tabpage, they will be
      automatically closed before the qflist is opened
    - If the quickfix list is already open, it will be focused
    - If a height is provided, and "nop_if_open" is not true, the qflist will
      be resized regardless of whether or not it is already open

    Parameters: ~
        {opts}  (QfrListOpenOpts)

    Returns: ~
        (boolean)


Window.open_loclist({src_win}, {opts})                     *Window.open_loclist*
    - If no location list is present for the source window, the function will
      exit
    - If the quickfix list is open in the same tabpage, it will be closed
      before the location list is opened
    - If the location list is already open, it will be focused
    - If a height is provided, and "nop_if_open" is not true, the location
      list will be resized regardless of whether or not it is already open

    Parameters: ~
        {src_win}  (integer) Location list window context
        {opts}     (QfrListOpenOpts)

    Returns: ~
        (boolean)


Window.close_qflist()                                      *Window.close_qflist*
    - If switchbuf contains uselast, focus will be changed to the alternate
      window if it is available

    Returns: ~
        (boolean)


Window.close_loclist({src_win})                           *Window.close_loclist*
    -If switchbuf contains uselast, focus will be changed to the alternate
     window if it is available
    - All location list windows sharing a |quickfix-ID| with the current
      window context will also be closed

    Parameters: ~
        {src_win}  (integer) Location list window context

    Returns: ~
        (boolean)


Window._toggle_qflist({opts})                            *Window._toggle_qflist*
    opts.nop_if_open will be automatically set to true

    Parameters: ~
        {opts}  (QfrListOpenOpts)

    Returns: ~
        (nil)


                                                        *Window._toggle_loclist*
Window._toggle_loclist({src_win}, {opts})
    opts.nop_if_open will be automatically set to true

    Parameters: ~
        {src_win}  (integer)
        {opts}     (QfrListOpenOpts)

    Returns: ~
        (nil)


Window.open_qflist_cmd({cargs})                         *Window.open_qflist_cmd*
    Qopen cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.open_loclist_cmd({cargs})                       *Window.open_loclist_cmd*
    Lopen cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.close_qflist_cmd()                              *Window.close_qflist_cmd*
    Qclose cmd callback

    Returns: ~
        (nil)


Window.close_loclist_cmd()                            *Window.close_loclist_cmd*
    Lclose cmd callback

    Returns: ~
        (nil)


Window.toggle_qflist_cmd({cargs})                     *Window.toggle_qflist_cmd*
    Qtoggle cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Window.toggle_loclist_cmd({cargs})                   *Window.toggle_loclist_cmd*
    Ltoggle cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Nav controls                                       *qf-rancher-nav-controls*

                                                               *qfr-nav-keymaps*
                                                              *qfr-nav-commands*


Modes: { n }, Plug: <Plug>(qfr-qf-prev), Default: "[q"
 Desc: Go to the [count] previous quickfix entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-next), Default: "]q"
 Desc: Go to the [count] next quickfix entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-rewind), Default: "[Q"
 Desc: Go to the [count] quickfix entry, or the first if no count

Modes: { n }, Plug: <Plug>(qfr-qf-last), Default: "]Q"
 Desc: Go to the [count] quickfix entry, or the last if no count

Modes: { n }, Plug: <Plug>(qfr-qf-pfile), Default: "[<C-q>"
 Desc: Go to the [count] previous quickfix file. Wrap to the last file

Modes: { n }, Plug: <Plug>(qfr-qf-nfile), Default: "]<C-q>"
 Desc: Go to the [count] next quickfix file. Wrap to the first file

Modes: { n }, Plug: <Plug>(qfr-ll-prev), Default: "[l"
 Desc: Go to the [count] previous location list entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-next), Default: "]l"
 Desc: Go to the [count] next location list entry. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-rewind), Default: "[L"
 Desc: Go to the [count] quickfix entry, or the first if no count

Modes: { n }, Plug: <Plug>(qfr-ll-last), Default: "]L"
 Desc: Go to the [count] quickfix entry, or the last if no count

Modes: { n }, Plug: <Plug>(qfr-ll-pfile), Default: "[<C-l>"
 Desc: Go to the [count] previous quickfix file. Wrap to the last file

Modes: { n }, Plug: <Plug>(qfr-ll-nfile), Default: "]<C-l>"
 Desc: Go to the [count] next quickfix file. Wrap to the first file

Cmd: Qprev
Desc: Go to the [count] previous quickfix entry. Count is wrapping

Cmd: Qnext
Desc: Go to the [count] next quickfix entry. Count is wrapping

Cmd: Qrewind
Desc: Go to the [count] quickfix entry, or the first if no count

Cmd: Qq
Desc: Go to the [count] qf entry, or under the cursor, or current idx

Cmd: Qlast
Desc: Go to the [count] quickfix entry, or the last if no count

Cmd: Qpfile
Desc: Go to the [count] previous quickfix file. Wrap to the last file

Cmd: Qnfile
Desc: Go to the [count] next quickfix file. Wrap to the first file

Cmd: Lprev
Desc: Go to the [count] previous location list entry. Count is wrapping

Cmd: Lnext
Desc: Go to the [count] next location list entry. Count is wrapping

Cmd: Ll
Desc: Go to the [count] loclist entry, or under the cursor, or current idx

Cmd: Lrewind
Desc: Go to the [count] quickfix entry, or the first if no count

Cmd: Llast
Desc: Go to the [count] quickfix entry, or the last if no count

Cmd: Lpfile
Desc: Go to the [count] previous quickfix file. Wrap to the last file

Cmd: Lnfile
Desc: Go to the [count] next quickfix file. Wrap to the first file

==============================================================================
Navigate lists                                                             *Nav*

                                                                *qf-rancher-nav*
                                                                       *qfr-nav*


NOTE: All navigation commands will auto-center the buffer view if
g:qfr_auto_center_result is true

Nav.q_prev({count}, {opts})                                         *Nav.q_prev*

    Parameters: ~
        {count}  (integer) Wrapping count previous entry to navigate to
        {opts}   (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.q_next({count}, {opts})                                         *Nav.q_next*

    Parameters: ~
        {count}  (integer) Wrapping count next entry to navigate to
        {opts}   (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.l_prev({src_win}, {count}, {opts})                              *Nav.l_prev*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count previous entry to navigate to
        {opts}     (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.l_next({src_win}, {count}, {opts})                              *Nav.l_next*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count next entry to navigate to
        {opts}     (table) Reserved for future use

    Returns: ~
        (boolean)


Nav.q_q({count})                                                       *Nav.q_q*
    If a count is provided, that list entry will be opened
    If no count is provided, and the window focus is on a list, the list item
    under the cursor will be opened (different from default cc/ll behavior)
    If the focus is not in a list, the current list idx will be used

    Parameters: ~
        {count}  (integer) Count entry to navigate to

    Returns: ~
        (nil)


Nav.l_l({src_win}, {count})                                            *Nav.l_l*

    Parameters: ~
        {src_win}  (integer) Count entry to navigate to
        {count}    (integer)

    Returns: ~
        (nil)


Nav.q_rewind({count})                                             *Nav.q_rewind*

    Parameters: ~
        {count}  (integer) Entry to navigate to. First if no count

    Returns: ~
        (nil)


Nav.q_last({count})                                                 *Nav.q_last*

    Parameters: ~
        {count}  (integer) Entry to navigate to. Last if no count

    Returns: ~
        (nil)


Nav.l_rewind({src_win}, {count})                                  *Nav.l_rewind*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Entry to navigate to. First if no count

    Returns: ~
        (nil)


Nav.l_last({src_win}, {count})                                      *Nav.l_last*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Entry to navigate to. Last if no count

    Returns: ~
        (nil)


Nav.q_pfile({count})                                               *Nav.q_pfile*
    NOTE: While the p/nfile commands will wrap to the first or last file
    when trying to navigate past the end, the count cannot be used to wrap to a
    specific entry like with the next/prev commands

    Parameters: ~
        {count}  (integer) Count previous file to navigate to

    Returns: ~
        (nil)


Nav.q_nfile({count})                                               *Nav.q_nfile*

    Parameters: ~
        {count}  (integer)

    Returns: ~
        (nil)


Nav.l_pfile({src_win}, {count})                                    *Nav.l_pfile*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Count previous file to navigate to

    Returns: ~
        (nil)


Nav.l_nfile({src_win}, {count})                                    *Nav.l_nfile*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Count next file to navigate to

    Returns: ~
        (nil)


Nav.q_prev_cmd({cargs})                                         *Nav.q_prev_cmd*
    Qprev cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_next_cmd({cargs})                                         *Nav.q_next_cmd*
    Qnext cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_prev_cmd({cargs})                                         *Nav.l_prev_cmd*
    Lprev cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_next_cmd({cargs})                                         *Nav.l_next_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_q_cmd({cargs})                                               *Nav.q_q_cmd*
    Qq cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_l_cmd({cargs})                                               *Nav.l_l_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_rewind_cmd({cargs})                                     *Nav.q_rewind_cmd*
    Qrewind cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_last_cmd({cargs})                                         *Nav.q_last_cmd*
    Qlast cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_rewind_cmd({cargs})                                     *Nav.l_rewind_cmd*
    Lrewind cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_last_cmd({cargs})                                         *Nav.l_last_cmd*
    Llast cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_pfile_cmd({cargs})                                       *Nav.q_pfile_cmd*
    Qpfile cmd callback. Expects count = 0 in the user_command table
    NOTE: While the p/nfile commands will wrap to the first or last file
    when trying to navigate past the end, the count cannot be used to wrap to a
    specific entry like with the next/prev commands

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.q_nfile_cmd({cargs})                                       *Nav.q_nfile_cmd*
    Qnfile cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_pfile_cmd({cargs})                                       *Nav.l_pfile_cmd*
    Lpfile cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Nav.l_nfile_cmd({cargs})                                       *Nav.l_nfile_cmd*
    Lnfile cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Stack controls                                   *qf-rancher-stack-controls*

                                                             *qfr-stack-keymaps*
                                                            *qfr-stack-commands*


Modes: { n }, Plug: <Plug>(qfr-qf-older), Default: "<leader>q["
 Desc: Go to the [count] older quickfix list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-newer), Default: "<leader>q]"
 Desc: Go to the [count] newer quickfix list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-qf-history), Default: "<leader>qQ"
 Desc: Jump to [count] list in the quickfix stack or view the current list

Modes: { n }, Plug: <Plug>(qfr-qf-del), Default: "<leader>qe"
 Desc: Delete a list from the quickfix stack

Modes: { n }, Plug: <Plug>(qfr-qf-del-all), Default: "<leader>qE"
 Desc: Clear the quickfix stack

Modes: { n }, Plug: <Plug>(qfr-ll-older), Default: "<leader>l["
 Desc: Go to the [count] older location list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-newer), Default: "<leader>l]"
 Desc: Go to the [count] newer location list. Count is wrapping

Modes: { n }, Plug: <Plug>(qfr-ll-history), Default: "<leader>lL"
 Desc: Jump to [count] list in the loclist stack or view the current list

Modes: { n }, Plug: <Plug>(qfr-ll-del), Default: "<leader>le"
 Desc: Delete a list from the loclist stack

Modes: { n }, Plug: <Plug>(qfr-ll-del-all), Default: "<leader>lE"
 Desc: Clear the loclist stack

Cmd: Qolder
Desc: Go to the [count] older quickfix list. Count is wrapping

Cmd: Qnewer
Desc: Go to the [count] newer quickfix list. Count is wrapping

Cmd: Qhistory
Desc: Jump to [count] list in the quickfix stack or show the entire stack

Cmd: Qdelete
Desc: Delete [count] list "all" lists from the quickfix stack

Cmd: Lolder
Desc: Go to the [count] older location list. Count is wrapping

Cmd: Lnewer
Desc: Go to the [count] newer location list. Count is wrapping

Cmd: Lhistory
Desc: Jump to [count] list in the loclist stack or show the entire stack

Cmd: Ldelete
Desc: Delete [count] list or "all" lists from the loclist stack

==============================================================================
View and edit the list stack                                             *Stack*

                                                              *qf-rancher-stack*
                                                                     *qfr-stack*


NOTE: If no list number is provided to next/previous commands, the default
is to cycle by one list
For commands that target a specific list, if no count is provided, the
current list will be used
NOTE: All navigation commands will re-size the list if it changes and
g:qfr_auto_list_height is true

Stack.q_older({count})                                           *Stack.q_older*

    Parameters: ~
        {count}  (integer) Wrapping count previous list to go to

    Returns: ~
        (nil)


Stack.q_newer({count})                                           *Stack.q_newer*

    Parameters: ~
        {count}  (integer) Wrapping count next list to go to

    Returns: ~
        (nil)


Stack.l_older({src_win}, {count})                                *Stack.l_older*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count previous list to go to

    Returns: ~
        (nil)


Stack.l_newer({src_win}, {count})                                *Stack.l_newer*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) Wrapping count next list to go to

    Returns: ~
        (nil)


QfrHistoryDefaultOpt                                      *QfrHistoryDefaultOpt*

    Whether to show the current list info or the entire stack
    (chistory/lhistory default) on 0 count

    Variants: ~
        ("cur_list")
        ("show_stack")


QfrHistoryOpts                                                  *QfrHistoryOpts*

    Fields: ~
        {open_list?}  (boolean) Open the list after changing history
        {default?}    (QfrHistoryDefaultOpt)
        {keep_win?}   (boolean) If true, don't change window focus
        {silent?}     (boolean) Suppress messages


Stack.q_history({count}, {opts})                               *Stack.q_history*

    Parameters: ~
        {count}  (integer) List number to go to
        {opts}   (QfrHistoryOpts)

    Returns: ~
        (nil)


Stack.l_history({src_win}, {opts})                             *Stack.l_history*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {opts}     (QfrHistoryOpts)

    Returns: ~
        (nil)


Stack.q_del({count})                                               *Stack.q_del*

    Parameters: ~
        {count}  (integer) List number to delete

    Returns: ~
        (nil)


Stack.l_del({src_win}, {count})                                    *Stack.l_del*

    Parameters: ~
        {src_win}  (integer) Location list window context
        {count}    (integer) List number to delete

    Returns: ~
        (nil)


Stack.q_del_all()                                              *Stack.q_del_all*

    Returns: ~
        (nil)


Stack.l_del_all({src_win})                                     *Stack.l_del_all*

    Parameters: ~
        {src_win}  (integer) Location list window context

    Returns: ~
        (nil)


Stack.q_older_cmd({cargs})                                   *Stack.q_older_cmd*
    Qolder cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.q_newer_cmd({cargs})                                   *Stack.q_newer_cmd*
    Qnewer cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_older_cmd({cargs})                                   *Stack.l_older_cmd*
    Lolder cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_newer_cmd({cargs})                                   *Stack.l_newer_cmd*
    Lnewer cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.q_history_cmd({cargs})                               *Stack.q_history_cmd*
    Qhistory cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_history_cmd({cargs})                               *Stack.l_history_cmd*
    Lhistory cmd callback. Expects count = 0 in the user_command table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


NOTE: If "all" is provided, any count is overridden
A count of zero deletes the current list

Stack.q_delete_cmd({cargs})                                 *Stack.q_delete_cmd*
    Qdelete cmd callback. Expects count = 0 and nargs = "?" in the command
    table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Stack.l_delete_cmd({cargs})                                 *Stack.l_delete_cmd*
    Ldelete cmd callback. Expects count = 0 and nargs = "?" in the command
    table

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Ftplugin controls                             *qf-rancher-ftplugin-controls*

                                                          *qfr-ftplugin-keymaps*


Modes: { n }, Plug: <Plug>(qfr-list-del-one), Default: "dd"
 Desc: Delete the current list line

Modes: { x }, Plug: <Plug>(qfr-list-visual-del), Default: "d"
 Desc: Delete a visual line list selection

Modes: { n }, Plug: <Plug>(qfr-list-toggle-preview), Default: "p"
 Desc: Toggle the list preview win

Modes: { n }, Plug: <Plug>(qfr-list-update-preview-pos), Default: "P"
 Desc: Update the preview win position

Modes: { n }, Plug: <Plug>(qfr-list-prev), Default: "{"
 Desc: Go to the previous list entry, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-next), Default: "}"
 Desc: Go to the next list entry, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-direct-focuswin), Default: "o"
 Desc: Open a list item

Modes: { n }, Plug: <Plug>(qfr-list-open-direct-focuslist), Default: "<C-o>"
 Desc: Open a list item, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-split-focuswin), Default: "s"
 Desc: Open a list item in a split

Modes: { n }, Plug: <Plug>(qfr-list-open-split-focuslist), Default: "<C-s>"
 Desc: Open a list item in a split, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-vsplit-focuswin), Default: "v"
 Desc: Open a list item in a vsplit

Modes: { n }, Plug: <Plug>(qfr-list-open-vsplit-focuslist), Default: "<C-v>"
 Desc: Open a list item in a vsplit, keep list focus

Modes: { n }, Plug: <Plug>(qfr-list-open-tabnew-focuswin), Default: "x"
 Desc: Open a list item in a new tab

Modes: { n }, Plug: <Plug>(qfr-list-open-tabnew-focuslist), Default: "<C-x>"
 Desc: Open a list item in a new tab, keep list focus

==============================================================================
List buffer specific features                                         *Ftplugin*

                                                           *qf-rancher-ftplugin*
                                                                  *qfr-ftplugin*


If g:qfr_ftplugin_set_opts is true, the following will be set:

- buflisted = false
- colorcolumn = ""
- list = false
- spell = false

If g:qfr_ftplugin_demap is true, disable the following defaults:

- <C-w>s (split)
- <C-w>v (vsplit)
- <C-i> / <C-o> (jumplist navigation)

The |qf-rancher-ftplugin-keymaps| will be set if g:qfr_ftplugin_keymap
is true.

Additionally, the "older" and "newer" functions will be mapped to "<" and ">"
Like the standard keymaps, they take a wrapping count

NOTE: The [count] for the ftplugin specific maps specifies which window
number to open the entry to. If no count is provided, Qfr will emulate
Neovim's default behavior. For Quickfix windows, this includes respecting
"useopen", "usetab", and "uselast" switchbuf behavior (Location list
windows use "useopen" only). Help entries will attempt to find a help
window If a valid window cannot be found, a new split will always be
created above the list

==============================================================================
Qfr Grep controls                                     *qf-rancher-grep-controls*

                                                              *qfr-grep-keymaps*
                                                             *qfr-grep-commands*


Modes: { n, x }, Plug: <Plug>(qfr-qgrep-cwd), Default: "<leader>qgd"
 Desc: Quickfix grep CWD (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-cwdX), Default: "<leader>qgD"
 Desc: Quickfix grep CWD (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-help), Default: "<leader>qgh"
 Desc: Quickfix grep help (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-helpX), Default: "<leader>qgH"
 Desc: Quickfix grep help (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cwd), Default: "<leader>lgd"
 Desc: Loclist grep CWD (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cwdX), Default: "<leader>lgD"
 Desc: Loclist grep CWD (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-help), Default: "<leader>lgh"
 Desc: Loclist grep help (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-helpX), Default: "<leader>lgH"
 Desc: Loclist grep help (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-bufs), Default: "<leader>qgu"
 Desc: Quickfix grep open bufs (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qgrep-bufsX), Default: "<leader>qgU"
 Desc: Quickfix grep bufs (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cbuf), Default: "<leader>lgu"
 Desc: Loclist grep cur buf (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lgrep-cbufX), Default: "<leader>lgU"
 Desc: Loclist grep cur buf (regex)

Cmd: Qgrep
Desc: Grep to the quickfix list

Cmd: Lgrep
Desc: Grep to the location list

==============================================================================
Grep items into the list                                                  *Grep*

                                                               *qf-rancher-grep*
                                                                      *qfr-grep*


QfrGrepLocs                                                        *QfrGrepLocs*

    Type: ~
        string[]


QfrGrepPartsFunc                                              *QfrGrepPartsFunc*
    Fields:
    - string pattern
    - string |QfrInputType|
    - QfrGrepLocs Locations to grep from
    Returns: string[]

    Type: ~
        fun(string:any,string:any,QfrGrepLocs:any):string[]


QfrGrepInfo                                                        *QfrGrepInfo*

    Fields: ~
        {name}            (string) Used for cmds and public API access
        {list_item_type}  (string|nil) Type to apply to resulting list items
        {location_func}   (fun():string[]) For providing locations to the grep


                                                                     *Grep.grep*
Grep.grep({name}, {input_opts}, {system_opts}, {output_opts})
    Run a registered grep function
    The list title will be set to:
    "[grep name] [base grep cmd] [pattern]"
    If g:qfr_reuse_title is true, output_opts.action is " ", and a list
    with the grep's title already exists, that list will be reused
    This command uses the system module to run the grep and print
    results
    TODO: Make a link to the system doc

    Parameters: ~
        {name}         (string) Will check all currently registered greps
        {input_opts}   (QfrInputOpts) See |qfr-input-opts|
                       If a pattern is provided, that will be used for the
                       grep. If not, the user will be prompted for one in
                       normal mode, or the current visual selection will be
                       used
        {system_opts}  (QfrSystemOpts) See |qfr-system-opts|
                       async will be used by default
        {output_opts}  (QfrOutputOpts) See |qfr-output-opts|
                       Any list_item_type provided here will be overridden
                       by the one provided in the grep config

    Returns: ~
        (nil)


Grep.register_grep({grep_info})                             *Grep.register_grep*
    Register a grep function for use in comands and API calls

    Parameters: ~
        {grep_info}  (QfrGrepInfo) The grep will be registered
                     under the name provided in this table

    Returns: ~
        (nil)


Grep.clear_grep({name})                                        *Grep.clear_grep*
    Remove a registered grep. The last grep cannot be removed

    Parameters: ~
        {name}  (string)

    Returns: ~
        (nil)


The callbacks to assign the Qgrep and Lgrep commands are below. They expect
count = 0 and nargs = "*" to be present in the user_command table.
They accept the following options:
- A registered grep name (cwd|help|bufs|cbuf). cwd is default
  NOTE: "bufs" searches all open bufs, excluding help bufs
  NOTE: "cbuf" searches the current buf, including help buffers
  NOTE: The built in quickfix buf grep keymap searches all open bufs.
  The location list grep searches the current buf
- A pattern starting with "/"
- A |qfr-input-type| ("vimcase" by default)
- "async" or "sync" to control system behavior (async by default)
- A |setqflist-action| (default " ")
Example: 2Qgrep help r vimcase /setqflist

Grep.q_grep_cmd({cargs})                                       *Grep.q_grep_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Grep.l_grep_cmd({cargs})                                       *Grep.l_grep_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Diagnostic controls                         *qf-rancher-diagnostic-controls*

                                                        *qfr-diagnostic-keymaps*
                                                       *qfr-diagnostic-commands*


Modes: { n }, Plug: <Plug>(qfr-Qdiags-hint), Default: "<leader>qin"
 Desc: All diagnostics to quickfix

Modes: { n }, Plug: <Plug>(qfr-Qdiags-info), Default: "<leader>qif"
 Desc: Diagnostics to quickfix, min info

Modes: { n }, Plug: <Plug>(qfr-Qdiags-warn), Default: "<leader>qiw"
 Desc: Diagnostics to quickfix, min warn

Modes: { n }, Plug: <Plug>(qfr-Qdiags-error), Default: "<leader>qie"
 Desc: Diagnostics to quickfix, min error

Modes: { n }, Plug: <Plug>(qfr-Qdiags-top), Default: "<leader>qit"
 Desc: Diagnostics to quickfix, top severity

Modes: { n }, Plug: <Plug>(qfr-Qdiags-hint-only), Default: "<leader>qiN"
 Desc: Diagnostics to quickfix, only hints

Modes: { n }, Plug: <Plug>(qfr-Qdiags-info-only), Default: "<leader>qiF"
 Desc: Diagnostics to quickfix, only info

Modes: { n }, Plug: <Plug>(qfr-Qdiags-warn-only), Default: "<leader>qiW"
 Desc: Diagnostics to quickfix, only warnings

Modes: { n }, Plug: <Plug>(qfr-Qdiags-error-only), Default: "<leader>qiE"
 Desc: Diagnostics to quickfix, only errors

Modes: { n }, Plug: <Plug>(qfr-Ldiags-hint), Default: "<leader>lin"
 Desc: All cur buf diagnostics to loclist

Modes: { n }, Plug: <Plug>(qfr-Ldiags-info), Default: "<leader>lif"
 Desc: Cur buf diagnostics to loclist, min info

Modes: { n }, Plug: <Plug>(qfr-Ldiags-warn), Default: "<leader>liw"
 Desc: Cur buf diagnostics to loclist, min warn

Modes: { n }, Plug: <Plug>(qfr-Ldiags-error), Default: "<leader>lie"
 Desc: Cur buf diagnostics to loclist, min error

Modes: { n }, Plug: <Plug>(qfr-Ldiags-top), Default: "<leader>lit"
 Desc: Cur buf diagnostics to loclist, top severity

Modes: { n }, Plug: <Plug>(qfr-Ldiags-hint-only), Default: "<leader>liN"
 Desc: Cur buf diagnostics to loclist, only hints

Modes: { n }, Plug: <Plug>(qfr-Ldiags-info-only), Default: "<leader>liF"
 Desc: Cur buf diagnostics to loclist, only info

Modes: { n }, Plug: <Plug>(qfr-Ldiags-warn-only), Default: "<leader>liW"
 Desc: Cur buf diagnostics to loclist, only warnings

Modes: { n }, Plug: <Plug>(qfr-Ldiags-error-only), Default: "<leader>liE"
 Desc: Cur buf diagnostics to loclist, only errors

Cmd: Qdiag
Desc: Send diags to the Quickfix list

Cmd: Ldiag
Desc: Send buf diags to the Location list

==============================================================================
Sends diags to the qf list                                                *Diag*

                                                        *qf-rancher-diagnostics*
                                                               *qfr-diagnostics*


QfrDiagOpts                                                        *QfrDiagOpts*

    Fields: ~
        {disp_func?}  (QfrDiagDispFunc) List entry conversion function
        {top?}        (boolean) If true, only show top severity
        {getopts?}    (vim.diagnostic.GetOpts) See |vim.diagnostic.Getopts|


                                                            *Diag.diags_to_list*
Diag.diags_to_list({diag_opts}, {output_opts})
    Convert diagnostics into list entries
    In line with Neovim's default, the list title will be "Diagnostics"
    If g:qfr_reuse_title is true, output_opts.action is " ", and a list with
    the title "Diagnostics" already exists, it will be re-used
    If a query is made for all diagnostics in a scope, and no results return,
    the "Diagnostics" list will be automatically cleared
    If g:qfr_auto_open_changes is true, the results will be automatically
    opened

    Parameters: ~
        {diag_opts}    (QfrDiagOpts)
        {output_opts}  (QfrOutputOpts) See |qfr-output-opts|

    Returns: ~
        (nil)


The callbacks to assign the Qdiag and Ldiag commands are below. They expect
count = 0, nargs = "*", and bang = true to be in the user_command table.

Qdiag checks all open buffers. Ldiag checks the current buffer

They accept the following options:
- A diagnostic severity ("error"|"warn"|"hint"|"info") or "top"
- A |setqflist-action| (default " ")

If a bang is provided, only the specified severity will be shown

Examples:
Qdiag error [show all errors]
Ldiag! warn only [show only warnings from the current buffer]

Diag.q_diag_cmd({cargs})                                       *Diag.q_diag_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Diag.l_diag_cmd({cargs})                                       *Diag.l_diag_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Filter controls                                 *qf-rancher-filter-controls*

                                                            *qfr-filter-keymaps*
                                                           *qfr-filter-commands*


Modes: { n, x }, Plug: <Plug>(qfr-qfilter-cfilter), Default: "<leader>qkl"
 Desc: Qfilter keep cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-cfilter), Default: "<leader>qrl"
 Desc: Qfilter remove cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-cfilterX), Default: "<leader>qkL"
 Desc: Qfilter keep cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-cfilterX), Default: "<leader>qrL"
 Desc: Qfilter remove cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-cfilter), Default: "<leader>lkl"
 Desc: Lfilter keep cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-cfilter), Default: "<leader>lrl"
 Desc: Lfilter remove cfilter (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-cfilterX), Default: "<leader>lkL"
 Desc: Lfilter keep cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-cfilterX), Default: "<leader>lrL"
 Desc: Lfilter remove cfilter (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-fname), Default: "<leader>qkf"
 Desc: Qfilter keep fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-fname), Default: "<leader>qrf"
 Desc: Qfilter remove fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-fnameX), Default: "<leader>qkF"
 Desc: Qfilter keep fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-fnameX), Default: "<leader>qrF"
 Desc: Qfilter remove fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-fname), Default: "<leader>lkf"
 Desc: Lfilter keep fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-fname), Default: "<leader>lrf"
 Desc: Lfilter remove fname (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-fnameX), Default: "<leader>lkF"
 Desc: Lfilter keep fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-fnameX), Default: "<leader>lrF"
 Desc: Lfilter remove fname (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-text), Default: "<leader>qke"
 Desc: Qfilter keep text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-text), Default: "<leader>qre"
 Desc: Qfilter remove text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-textX), Default: "<leader>qkE"
 Desc: Qfilter keep text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-textX), Default: "<leader>qrE"
 Desc: Qfilter remove text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-text), Default: "<leader>lke"
 Desc: Lfilter keep text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-text), Default: "<leader>lre"
 Desc: Lfilter remove text (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-textX), Default: "<leader>lkE"
 Desc: Lfilter keep text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-textX), Default: "<leader>lrE"
 Desc: Lfilter remove text (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-lnum), Default: "<leader>qkn"
 Desc: Qfilter keep lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-lnum), Default: "<leader>qrn"
 Desc: Qfilter remove lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-lnumX), Default: "<leader>qkN"
 Desc: Qfilter keep lnum (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-lnumX), Default: "<leader>qrN"
 Desc: Qfilter remove lnum (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-lnum), Default: "<leader>lkn"
 Desc: Lfilter keep lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-lnum), Default: "<leader>lrn"
 Desc: Lfilter remove lnum (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-lnumX), Default: "<leader>lkN"
 Desc: Lfilter keep lnum (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-lnumX), Default: "<leader>lrN"
 Desc: Lfilter remove lnum (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-type), Default: "<leader>qkt"
 Desc: Qfilter keep type (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-type), Default: "<leader>qrt"
 Desc: Qfilter remove type (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter-typeX), Default: "<leader>qkT"
 Desc: Qfilter keep type (regex)

Modes: { n, x }, Plug: <Plug>(qfr-qfilter!-typeX), Default: "<leader>qrT"
 Desc: Qfilter remove type (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-type), Default: "<leader>lkt"
 Desc: Lfilter keep type (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-type), Default: "<leader>lrt"
 Desc: Lfilter remove type (vimcase)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter-typeX), Default: "<leader>lkT"
 Desc: Lfilter keep type (regex)

Modes: { n, x }, Plug: <Plug>(qfr-lfilter!-typeX), Default: "<leader>lrT"
 Desc: Lfilter remove type (regex)

Cmd: Qfilter
Desc: Filter quickfix items

Cmd: Lfilter
Desc: Filter location list items

==============================================================================
Filter list items                                                       *Filter*

                                                             *qf-rancher-filter*
                                                                    *qfr-filter*


                                                     *qf-rancher-predicate-opts*
                                                            *qfr-predicate-opts*
QfrPredicateOpts                                              *QfrPredicateOpts*
    NOTE: Each predicate function will use one or the other

    Fields: ~
        {pattern?}  (string) Pattern to filter against
        {regex?}    (vim.regex) Regex to filter against


                                                   *qf-rancher-filter-predicate*
                                                          *qfr-filter-predicate*
QfrFilterPredicate                                          *QfrFilterPredicate*
    Fields:
    - vim.qflist.entry
    - boolean
    - QfrPredicateOpts
    Returns: boolean

    Type: ~
        fun


                                                        *qf-rancher-filter-info*
                                                               *qfr-filter-info*
QfrFilterInfo                                                    *QfrFilterInfo*
    NOTE: The filter logic will resolve vimcase and smartcase to either
    case-sensitive or insensitive

    Fields: ~
        {name}              (string) Name if the filter, used for cmds
        {insensitive_func}  (QfrFilterPredicate) Case-insensitive predicate
        {regex_func}        (QfrFilterPredicate) Regex predicate
        {sensitive_func}    (QfrFilterPredicate) Case-sensitive predicate


                                                                 *Filter.filter*
Filter.filter({name}, {keep}, {input_opts}, {output_opts})

    Parameters: ~
        {name}         (string)
        {keep}         (boolean) If true, matched patterns will be
                       kept in the list. If false, removed
        {input_opts}   (QfrInputOpts) See |qfr-input-opts|
                       If a pattern is provided, that will be used for the
                       filter. If not, the user will be prompted for one in
                       normal mode, or the current visual selection will be
                       used
        {output_opts}  (QfrOutputOpts) See |qfr-output-opts|
                       If vim.v.count is > 0, that will be used to
                       determine the list nr to be acted on

    Returns: ~
        (nil)


Filter.register_filter({filter_info})                   *Filter.register_filter*
    Register a fitler for use in commands and API Calls

    Parameters: ~
        {filter_info}  (QfrFilterInfo) The filter will be
                       registered under the name provided in this table

    Returns: ~
        (nil)


Filter.clear_filter({name})                                *Filter.clear_filter*
    Remove a registered filter. The last filer cannot be removed

    Parameters: ~
        {name}  (string)

    Returns: ~
        (nil)


The callbacks to assign the Qfilter and Lfilter commands are below. They
expect count = 0 and nargs = "*" to be present in the user_command table.
They accept the following options:
- A registered filter name. (cfilter|fname|lnum|text|type) cfilter is default
  NOTE: The "cfilter" option is an emulation of the built-in Cfilter plugin
  NOTE: For the "lnum" filter, the case-insensitive filter will function like
     a "contains" filter, whereas the case-sensitive filter requires an exact
     match
- A pattern starting with "/"
- A |qfr-input-type| ("vimcase" by default)
- A |setqflist-action| (default "u")
- If a bang is provided, the filter will remove instead of keeping matched
  items
- If a count is provided, that list number will be used. The default is the
  current list
Example: 3Qfilter! cfilter r vimcase /require

Filter.q_filter_cmd({cargs})                               *Filter.q_filter_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Filter.l_filter_cmd({cargs})                               *Filter.l_filter_cmd*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


==============================================================================
Qfr Sort controls                                     *qf-rancher-sort-controls*

                                                              *qfr-sort-keymaps*
                                                             *qfr-sort-commands*


Modes: { n }, Plug: <Plug>(qfr-qsort-fname-asc), Default: "<leader>qtf"
 Desc: Sort quickfix by fname asc

Modes: { n }, Plug: <Plug>(qfr-qsort-fname-desc), Default: "<leader>qtF"
 Desc: Sort quickfix by fname desc

Modes: { n }, Plug: <Plug>(qfr-qsort-fname-diag-asc), Default: "<leader>qtif"
 Desc: Sort quickfix by fname_diag asc

Modes: { n }, Plug: <Plug>(qfr-qsort-fname-diag-desc), Default: "<leader>qtiF"
 Desc: Sort quickfix by fname_diag desc

Modes: { n }, Plug: <Plug>(qfr-qsort-severity-asc), Default: "<leader>qtis"
 Desc: Sort quickfix by severity asc

Modes: { n }, Plug: <Plug>(qfr-qsort-severity-desc), Default: "<leader>qtiS"
 Desc: Sort quickfix by severity desc

Modes: { n }, Plug: <Plug>(qfr-qsort-text-asc), Default: "<leader>qte"
 Desc: Sort quickfix by text asc

Modes: { n }, Plug: <Plug>(qfr-qsort-text-desc), Default: "<leader>qtE"
 Desc: Sort quickfix by text desc

Modes: { n }, Plug: <Plug>(qfr-qsort-type-asc), Default: "<leader>qtt"
 Desc: Sort quickfix by type asc

Modes: { n }, Plug: <Plug>(qfr-qsort-type-desc), Default: "<leader>qtT"
 Desc: Sort quickfix by type desc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-asc), Default: "<leader>ltf"
 Desc: Sort location list by fname asc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-desc), Default: "<leader>ltF"
 Desc: Sort location list by fname desc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-diag-asc), Default: "<leader>ltif"
 Desc: Sort location list by fname_diag asc

Modes: { n }, Plug: <Plug>(qfr-lsort-fname-diag-desc), Default: "<leader>ltiF"
 Desc: Sort location list by fname_diag desc

Modes: { n }, Plug: <Plug>(qfr-lsort-severity-asc), Default: "<leader>ltis"
 Desc: Sort location list by severity asc

Modes: { n }, Plug: <Plug>(qfr-lsort-severity-desc), Default: "<leader>ltiS"
 Desc: Sort location list by severity desc

Modes: { n }, Plug: <Plug>(qfr-lsort-text-asc), Default: "<leader>lte"
 Desc: Sort location list by text asc

Modes: { n }, Plug: <Plug>(qfr-lsort-text-desc), Default: "<leader>ltE"
 Desc: Sort location list by text desc

Modes: { n }, Plug: <Plug>(qfr-lsort-type-asc), Default: "<leader>ltt"
 Desc: Sort location list by type asc

Modes: { n }, Plug: <Plug>(qfr-lsort-type-desc), Default: "<leader>ltT"
 Desc: Sort location list by type desc

Cmd: Qsort
Desc: Sort quickfix items

Cmd: Lsort
Desc: Sort location list items

==============================================================================
Sends diags to the qf list                                                *Sort*

                                                               *qf-rancher-sort*
                                                                      *qfr-sort*


                                                     *qf-rancher-sort-predicate*
                                                            *qfr-sort-predicate*
QfrSortPredicate                                              *QfrSortPredicate*
    Parameters:
    - vim.qflist.item (first item to sort)
    - vim.qflist.item (second item to sort)
    Return: Boolean

    Type: ~
        fun


                                                          *qf-rancher-sort-info*
                                                                 *qfr-sort-info*
QfrSortInfo                                                        *QfrSortInfo*

    Fields: ~
        {name}       (string) The name of the sort
        {asc_func}   (QfrSortPredicate) Predicate for asc sorts
        {desc_func}  (QfrSortPredicate) Predicate for desc sorts


QfrSortOpts                                                        *QfrSortOpts*

    Fields: ~
        {dir}  (QfrSortDir) "asc"|"desc"


                                                          *qf-rancher-sort-opts*
                                                                 *qfr-sort-opts*
Sort.register_sort({sort_info})                             *Sort.register_sort*
    Register a sort for use in commands and API calls

    Parameters: ~
        {sort_info}  (QfrSortInfo) See |qfr-sort-info| The sort will be
                     registered under the name provided in this table

    Returns: ~
        (nil)


Sort.clear_sort({name})                                        *Sort.clear_sort*
     Clears the function name from the registered sorts

    Parameters: ~
        {name}  (string)


                                                                     *Sort.sort*
Sort.sort({name}, {sort_opts}, {output_opts})
    Run a registered sort

    Parameters: ~
        {name}         (string) Which registered sort to run
        {sort_opts}    (QfrSortOpts) See |QfrSortOpts|
        {output_opts}  (QfrOutputOpts) See |qfr-output-opts|

    Returns: ~
        (nil)


The callbacks to assign the Qsort and Lsort commands are below. They
expect count = 0 and nargs = 1 to be present in the user_command table.
They accept the following options:
- A registered sort name (fname|fname_diag|severity|text|type)
  fname is the default
  NOTE: fname_diag sorts by filename, with subsorting by diagnostic
  severity
- A |setqflist-action| can also be provided (default "u")
- If a bang is provided, the sort will be in descending order
- If a count is provided, that list nr will be used. Default is the current
  list
Example: 4Qsort! fname r

Sort.q_sort({cargs})                                               *Sort.q_sort*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


Sort.l_sort({cargs})                                               *Sort.l_sort*

    Parameters: ~
        {cargs}  (vim.api.keyset.create_user_command.command_args)

    Returns: ~
        (nil)


The below sort predicates are exposed for use in other functions. All have
the type |QfrSortPredicate|

Sort.sort_fname_asc()                                      *Sort.sort_fname_asc*
    Sort by filename asc. Break ties with line and column numbers


Sort.sort_fname_desc()                                    *Sort.sort_fname_desc*
    Sort by filename desc. Break ties with line and column numbers


Sort.sort_text_asc()                                        *Sort.sort_text_asc*
    Sort by text asc


Sort.sort_text_desc()                                      *Sort.sort_text_desc*
    Sort by text desc


Sort.sort_type_asc()                                        *Sort.sort_type_asc*
    Sort by list item type asc


Sort.sort_type_desc()                                      *Sort.sort_type_desc*
    Sort by list item type desc


Sort.sort_fname_diag_asc()                            *Sort.sort_fname_diag_asc*
    Sort by filename asc, break ties by diagnostic severity


Sort.sort_fname_diag_desc()                          *Sort.sort_fname_diag_desc*
    Sort by filename desc, break ties by diagnostic severity


Sort.sort_severity_asc()                                *Sort.sort_severity_asc*
    Sort by diagnostic severity asc


Sort.sort_severity_desc()                              *Sort.sort_severity_desc*
    Sort by diagnostic severity desc


vim:tw=78:ts=8:noet:ft=help:norl:
